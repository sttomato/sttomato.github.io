<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[值得学习的博客]]></title>
      <url>%2F2017%2F10%2F30%2F%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[爱可可老师 litten的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫——从入门到肾亏]]></title>
      <url>%2F2017%2F10%2F27%2F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%82%BE%E4%BA%8F%2F</url>
      <content type="text"><![CDATA[最近，懒癌晚期生不如死贪生怕死的摸鱼狂魔不想改论文又害怕被老板骂的纠结心情下，想找点事情放松一下，就尝试开车做了一点爬虫。 概述效果基本还阔以，有会爬的网站，也有不会的，罗列一下。 爬到东西的网站： 小猪短租 (爬了一些房源信息，比如价格，地理位置之类的) 煎蛋网 (三俗图片) B站相册 (cos + 画册) 福利社 (内容和站名一样耿直，不解释了) 没爬到东西的网站： 网易LOFTER (目前只会爬一个页面，页面跳转需要点击网页元素，不支持粗暴的url爬取) 花瓣网 (可能是需要登录或者加headers设置，没搞定，没爬到东西) 除了小猪短租是文本其他的都主要是以图片为主，其实小猪上的文本还是很有价值的，比如分析地理位置和价格的关系，统计一下房东有多少套房之类的，这些都没有做，统统没有做，最简单的都没有，这次只为开车！ 下面简单说一下，我为躲避科研都干了啥。 煎蛋网 域名(url)：https://jandan.net/ 选择，“妹子图”，点进去后的地址是长这样的 “https://jandan.net/ooxx“ (你看看这链接←_←)，整个“妹子图”版块是像贴吧一样盖楼盖起来的，然后当前页面是该主题下的最后一页。 我们找到第一页。在没搞爬虫之前我想到只有一页页往回翻，但这太慢了，等真翻到第一页，早就软了。其实，我们发现翻了一页之后链接地址就大概是这样了 “https://jandan.net/ooxx/page-234#comments“ ，看到page后面的数字了么，所以只要改数字就可以翻页了么？是的，这个网站就这么搞。链接 “https://jandan.net/ooxx/page-1#comments“ 就是“妹子图”版块的第一页(网易LOFTER让我爬不动的原因就是此路不通，毕竟我还是一个宝宝┑(￣Д ￣)┍)。所以理论上，现在我们可以爬取从当前页到第一页的所有页面了。 还有一个坑是，图片右键“检查”之后，定位到的图片链接不是原图，导致两个问题。第一，爬到的jpg图片比原图略小，从省流量的角度看，这个尚可以忍受；第二，gif图片不仅变小了很多，而且还特么不动了！这还撸个毛(／‵口′)／~╧╧，正当我紧张到汗流浃背不知所措的时候，我发现原图的链接就在定位链接的上面(°Д°)。 这样基本就可以写代码了，用python的BeautifulSoup库就可以搞定了。目前总共有235个页面，我心慈手软就只爬了100个页面，主要原因还是营养快线学校流量太贵了。 成果展示一下: 好了，不能更多了，溜了溜了~ B站相册 域名(url)：https://h.bilibili.com/ 进入cosplay页面，地址”https://h.bilibili.com/eden/picture_area#/?class=cos&amp;tag=&amp;dateSort=%E6%8E%A8%E8%8D%90“ ，从链接来看，唔……瞬间懵逼，然后尝试右键”检查”(啊，喂！不要对着妹子的内衣点检查啊，混蛋！)，然后点击上方的Network标签，勾选Hide data URLs，点击XHR，然后刷新网站，从罗列出来的信息中，找到一个名字很长的，叫……太长了不列出来了，见下图。然后食指快速拨弄鼠标右键两次直到页面颤抖着弹出一个新的窗口，进入下一步。 新弹出来页面里都是文本信息，但是却包含了想要爬取的全部内容(不包括coser的三围)，其文本组建形式用的是JSON，我没怎么用过这个库，顺手就把她解析成了python的字典类型，然后再一层层探进去，想要啥就摸啥了，没啥抵抗能力的⁄(⁄⁄•⁄ω⁄•⁄⁄)⁄。我主要取了coser的昵称、主题当然还有图片这三个信息用于保存。 碰到的坑，我一开始的想法是把coser的主题作为文件夹，然后在文件夹下面用coser昵称命名，以tomato为例，就是tomato_1.avijpg，tomtao_2.jpg……以此类推。碰到两个问题，一个是coser命名的主题和昵称有可能不符合文件或文件夹命名规范，删除或者替换违法字符；二，用coser的昵称作为文件夹，然后用主题命名图片更好，因为有些coser还真是相当高产呢(当然也可以在昵称文件夹下再建立一个主题文件夹) 效果展示如下： 另外，还爬取了绘画的相册，方法一毛一样，这次把文件目录整理得更好一点惹。 福利社写到这里，我的羞耻感快要爆棚了。 域名(url): “http://www.182fl.com/?cate=6&amp;page=1“ 这是随手找到的一个野生写真女郎福利站(那个说我从收藏夹里翻出来的同学，今晚你没有营养快线喝了)，对于爬虫萌新来说简直不能更友好。老办法，对着图片右键检查，定位的地方不是想要的图片地址这个套路大家已经都懂了，只要爬取上一层结构中的地址就可以，基于此地址就是模特图集地址了~ 由于每个模特的图集页数不是一个固定的数字，也就是说我不知道总共有多少页，如果用爬“煎蛋网”的方法来处理就会出错。当我正在思考如何爬取该图集下全部图片的时候，我发现了下图这个。点击“显示全文”，地址变成了”http://www.182fl.com/?id=4725&amp;page=all“ ，也就是说只要在第2步中加上’&amp;page=all’就可以获得这个整个图集下面的图片链接了。 这个基本没有啥坑，效果如下(因为还在图书馆，细节先不放了。对，我还要脸(￣▽￣)： 代码地址还在考虑要不要放代码。主要原因，没别的，还是……要脸 (ﾉ) ｪ(ヾ)实在想看的话，可以去我的gay吧……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dynamic Programming]]></title>
      <url>%2F2017%2F10%2F11%2FDynamic-Programming%2F</url>
      <content type="text"><![CDATA[概述 定义：将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。 设计感比较强 艺术性比较强递归 原斐波那契数列，算法复杂度O(2^n) 12345int fib(int n) &#123; if (n == 0 || n == 1) return n; return fib(n - 1) + fib(n - 2);&#125; 优化， 加入一个数组保存每次运算的值 记忆化搜索 自上而下的解 123456789vector&lt;int&gt; memo(n + 1, -1);int fib(int n) &#123; if (n == 0 || n == 1) return n; if (memo[n] == -1) &#123; memo[n] = fib(n - 1) + fib(n - 2); &#125; return memo[n];&#125; 动态规划 自下而上的解 12345678910int fib(int n) &#123; vector&lt;int&gt; memo(n + 1, -1); memo[0] = 0; memo[1] = 1; for (int i = 2; i &lt;= n; i ++) &#123; memo[i] = memo[i - 1] + memo[i - 2]; &#125; return memo[n];&#125; LeetCode练习题 No.120 Triangle No.64 Minimum Path Sum 例题：No.343 Integer Break记忆化搜索：自顶向下12345678910111213141516171819202122int max3(int a, int b, int c) &#123; return max(a, max(b, c));&#125;int breakInteger(int n, vector&lt;int&gt;&amp; memo) &#123; if (n == 1) return 1; if (memo[n] != -1) &#123; return memo[n]; &#125; int res = -1; for (int i = 1; i &lt; n; i ++) &#123; res = max3(res, i * (n - i), i * breakInteger(n - i, memo)); &#125; memo[n] = res; return memo[n];&#125;int integerBreak(int n) &#123; vector&lt;int&gt; memo(n+1, -1); return breakInteger(n, memo);&#125; 动态规划：自下而上123456789101112int integerBreak(int n ) &#123; vector&lt;int&gt; memo(n + 1, -1); memo[1] = 1; for (int i = 2; i &lt;= n; i ++) &#123; //对每个可能的i进行遍历 for (int j = 1; j &lt; i; j ++) &#123;// i下面每个可能的组合：(j, i - j) //对三种情况比较，1. 内存中前最大值；2. 当前组合(i, i - j)的乘积值；3.i - j可能的组合最大值乘j memo[i] = max3(memo[i], j * (i - j), j * memo[i - j]); &#125; &#125; return memo[n];&#125; LeetCode练习题 No.279 Perfect Squares 123456789101112131415161718192021class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) return 0; vector&lt;int&gt; step(n + 1, INT_MAX); step[0] = 0; step[1] = 1; for (int i = 2; i &lt;= n; i ++) &#123; int j = 1; while (i &gt;= j) &#123; step[i] = min(step[i], step[i - j * j] + 1); j ++; &#125; &#125; return step[n]; &#125;&#125;; No.91 Decode Ways No.62 Unique Paths No.63 Unique PathsII 例题：No.198 House Robber状态转移12345678910111213141516171819class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); if (n == 1) return nums[0]; vector&lt;int&gt; price(n + 1, 0); price[1] = nums[0]; price[2] = nums[1]; for (int i = 2; i &lt; n; i++) &#123; price[i + 1] = max(price[i - 1], price[i - 2]) + nums[i]; &#125; return max(price[n], price[n - 1]); &#125;&#125;; LeetCode练习题 No.213 House Robber II No.337 House Robber III No.309 Best Time to Buy and Sell Stock with Cooldown 看不懂，不会做啊啊啊！！！w(ﾟДﾟ)w 12345678910111213141516171819202122class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if (n == 0) return 0; vector&lt;int&gt; buy(n, 0); vector&lt;int&gt; sell(n, 0); vector&lt;int&gt; rest(n, 0); buy[0] = 0 - prices[0]; sell[0] = 0; rest[0] = 0; for (int i = 1; i &lt; n; i ++) &#123; buy[i] = max(rest[i - 1] - prices[i], buy[i - 1]); sell[i] = max(buy[i - 1] + prices[i], sell[i - 1]); //rest[i] = max(buy[i - 1], max(sell[i - 1], rest[i - 1])); rest[i] = sell[i - 1]; &#125; return sell[n - 1]; &#125;&#125;; 背包问题：例题练习题： 完全背包问题 多维费用背包问题 最长上升子序列例题：No.300 Longest Increasint Subsequence1234567891011121314151617int lengthOfLIS(vector&lt;int&gt; nums) &#123; int n = nums.size(); if (n == 0) return 0; vector&lt;int&gt; len(n, 1); int res = 0; for (int i = 0; i &lt; n; ++) &#123; for (int j = i - 1; j &gt;= 0; j --) &#123; if (nums[i] &gt; nums[j]) &#123; len[i] = max(len[i], len[j] + 1); &#125; &#125; res = max(res, len[i]); &#125; return res;&#125; LeetCode练习题 No.376 Wiggle Subsequence O(n^2)的解法，更好懂一些 12345678910111213141516171819class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) return 0; vector&lt;int&gt; larger(n, 1); vector&lt;int&gt; less(n, 1); for (int i = 1; i &lt; n; i ++) &#123; for (int j = 0; j &lt; i; j ++) &#123; if (nums[i] &gt; nums[j]) larger[i] = max(larger[i], less[j] + 1); if (nums[i] &lt; nums[j]) &#123; less[i] = max(less[i], larger[j] + 1); &#125; &#125; &#125; return max(larger[n - 1], less[n - 1]); &#125;&#125;; o(n)的解法，我至今是懵逼的 123456789101112131415161718192021222324class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) return 0; vector&lt;int&gt; larger(n, 1); vector&lt;int&gt; less(n, 1); for (int i = 1; i &lt; n; i ++) &#123; if (nums[i] &gt; nums[i - 1]) &#123; larger[i] = less[i - 1] + 1; less[i] = less[i - 1]; &#125; if (nums[i] &lt; nums[i - 1]) &#123; less[i] = larger[i - 1] + 1; larger[i] = larger[i - 1]; &#125; if (nums[i] == nums[i - 1]) &#123; larger[i] = larger[i - 1]; less[i] = less[i - 1]; &#125; &#125; return max(larger[n - 1], less[n - 1]); &#125;&#125;; 最长公共子序列12345678910111213141516171819202122int LCS(string a, string b) &#123; int n = a.size(); int m = b.size(); if (n == 0 || m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; memo(n, vector&lt;int&gt;(m + 1, 0)); for (int j = 1; j &lt;= m; j ++) &#123; memo[0][j] = max(memo[0][j - 1], a[0] == b[j - 1] ? 1 : 0); &#125; for (int i = 1; i &lt; n; i ++) &#123; for (int j = 1; j &lt;= m; j ++) &#123; if (b[j - 1] == a[i]) &#123; memo[i][j] = memo[i - 1][j - 1] + 1; &#125; else &#123; memo[i][j] = max(memo[i - 1][j], memo[i][j - 1]); &#125; &#125; &#125; return memo[n - 1][m];&#125; dijkstra单源最短路径算法有权图最短路径 shortestPath(i) = min(shortestPath(j) + w(i, j))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Recursion & Backtracking]]></title>
      <url>%2F2017%2F10%2F09%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
      <content type="text"><![CDATA[回溯： 在递归中暴力穷举，算法复杂度O(2^n) 难点 状态回溯 终止条件 剪枝 一般的回溯问题字符串问题例题：No.17 Letter Combinations of a Phone Numbers12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: const string letterMap[10] = &#123; " ", // 0 "", //1 "abc", //2 "def", //3 "ghi", //4 "jkl", //5 "mno", //6 "pqrs", //7 "tuv", //8 "wxyz", //9 &#125;;/* void findCombination(string digits, int index, string s, vector&lt;string&gt;&amp; res) &#123; if (index == digits.size()) &#123; res.push_back(s); return; &#125; char c = digits[index]; string letters = letterMap[c - '0']; for (int i = 0; i &lt; letters.size(); i ++) &#123; //状态回溯在调用中实现 findCombination(digits, index + 1, s + letters[i], res); &#125; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return &#123;&#125;; vector&lt;string&gt; res; findCombination(digits, 0, "", res); return res; &#125;*/ vector&lt;string&gt; findCombination(string digits, int index, string s) &#123; vector&lt;string&gt; res; if (index == digits.size()) &#123; res.push_back(s); return res; &#125; char c = digits[index]; string letters = letterMap[c - '0']; for (int i = 0; i &lt; letters.size(); i ++) &#123; vector&lt;string&gt; tmp = findCombination(digits, index + 1, s + letters[i]); for (auto v : tmp) res.push_back(v); &#125; return res; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return &#123;&#125;; vector&lt;string&gt; res = findCombination(digits, 0, ""); return res; &#125; &#125;; 以前写得解 LeetCode练习题 No.93 Restore IP Addresses No.131 Palindrome Parititioning 排列问题例题：No.46 Permutation 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return &#123;&#125;; vector&lt;int&gt; p; int n = nums.size(); vector&lt;bool&gt; used(n, false); generatePermutation(nums, p, used); return res; &#125; void generatePermutation(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; p, vector&lt;bool&gt;&amp; used) &#123; if (p.size() == nums.size()) &#123; res.push_back(p); return; &#125; for (int i = 0; i &lt; nums.size(); i ++) &#123; if (!used[i]) &#123; used[i] = true; p.push_back(nums[i]); generatePermutation(nums, p, used); p.pop_back(); //状态回溯 used[i] = false; //状态回溯 &#125; &#125; &#125; &#125;; 以前的解LeetCode练习题 No.47 Permutations II 组合问题例题 No.77 Combinations 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; res;void generateCombinations(int n, int k, int start, vector&lt;int&gt;&amp; tmp) &#123; if (tmp.size() == k) &#123; res.push_back(tmp); return; &#125; for (int i = start; i &lt;= n; i ++) &#123; tmp.push_back(i); generateCombinations(n, k, start + 1, tmp);//错误之处，start应该为i tmp.pop_back(); //状态回溯 &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if (n &lt;= 0) return &#123;&#125;; vector&lt;int&gt; tmp; generateCombinations(n, k, 1, tmp); return res;&#125; 剪枝优化之后12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; res;void generateCombinations(int n, int k, int start, vector&lt;int&gt;&amp; tmp) &#123; if (tmp.size() == k) &#123; // 终止条件改为 k == 0 否则无法退出 res.push_back(tmp); return; &#125; //for (int i = start; i &lt;= n - (k - tmp.size()) + 1; i++) &#123; //其他不改，只改这里也可以 for (int i = start; i &lt;= n - k + 1; i ++) &#123; tmp.push_back(i); generateCombinations(n, k - 1, start + 1, tmp);//错误之处，start应该为i tmp.pop_back(); //状态回溯 &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if (n &lt;= 0) return &#123;&#125;; vector&lt;int&gt; tmp; generateCombinations(n, k, 1, tmp); return res;&#125; LeetCode练习题 No.39 Combination Sum No.40 Combination Sum II No.216 Combination Sum III No.78 Subsets No.90 Subsets II No.401 Binary Watch 二维平面上的回溯二维平面上回溯的一般做法例题： No.79 Word Search floodfill算法(深度优先)例题：No.200 Number of Islands 和普通回溯相比，没有状态回溯的过程12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int m,n; int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;; bool inArea(int x, int y) &#123; return (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n); &#125; int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if (grid.empty()) return 0; m = grid.size(); n = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; used(m, vector&lt;bool&gt;(n, false)); int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == '1' &amp;&amp; used[i][j] == false) &#123; count ++; used[i][j] = true; func(grid, used, i, j); &#125; &#125; &#125; return count; &#125; void func(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; used, int pos_x, int pos_y) &#123; for (int i = 0; i &lt; 4; i ++) &#123; int x = pos_x + d[i][0]; int y = pos_y + d[i][1]; if (inArea(x, y) &amp;&amp; used[x][y] == false &amp;&amp; grid[x][y] == '1') &#123; used[x][y] = true; func(grid, used, x, y); &#125; &#125; &#125;&#125;; LeetCode练习题 No.130 Surrounded Regions 此题的神奇之处在于，如果用辅助数组来保存访问状态的话，会超时，也就是被注释掉的used数组；借助自身值来表示状态可以解决这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: int m, n; int d[4][2] = &#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;; bool inArea(int x, int y) &#123; return (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n); &#125; void func(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos_x, int pos_y/*, vector&lt;vector&lt;bool&gt;&gt;&amp; used*/) &#123; //used[pos_x][pos_y] = true; board[pos_x][pos_y] = '*'; for (int i = 0; i &lt; 4; i++) &#123; int x = pos_x + d[i][0]; int y = pos_y + d[i][1]; //if (inArea(x, y) &amp;&amp; board[x][y] == 'O' &amp;&amp; used[x][y] == false) &#123; if (inArea(x, y) &amp;&amp; board[x][y] == 'O') &#123; func(board, x, y); &#125; &#125; &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.empty()) return; m = board.size(); n = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; used(m, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; m; i ++) &#123; int j = 0; if (board[i][j] == 'O') &#123; func(board, i, j); &#125; j = n - 1; if (board[i][j] == 'O')&#123; func(board, i, j); &#125; &#125; for (int j = 1; j &lt; n - 1; j++) &#123; int i = 0; if (board[i][j] == 'O') &#123; func(board, i, j); &#125; i = m - 1; if (board[i][j] == 'O') &#123; func(board, i, j); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O') &#123; board[i][j] = 'X'; &#125; if (board[i][j] == '*') &#123; board[i][j] = 'O'; &#125; &#125; &#125; &#125;&#125;; No.417 Pacific Atlantic Water Flow 人工智能类应用例题: No.51 N-Queens 123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;string&gt; input;vector&lt;int&gt; saved;void func(int index, int n, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; for (int j = 0; j &lt; index - 1; j++) &#123; if (abs(j - (index - 1)) == abs(saved[j] - saved[index - 1])) return; &#125; if (index == n) &#123; vector&lt;string&gt; tmp; for (int i = 0; i &lt; n; i ++) tmp.push_back(input[saved[i]]); res.push_back(tmp); return; &#125; for (int i = 0; i &lt; n; i ++) &#123; if (used[i] == false) &#123; used[i] = true; saved.push_back(i); func(index + 1, n, used, res); saved.pop_back(); used[i] = false; &#125; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;bool&gt; used(n, false); vector&lt;vector&lt;string&gt;&gt; res; for (int i = 0; i &lt; n; i++) &#123; string tmp = ""; for (int j = 0; j &lt; n; j++) &#123; if (i == j) tmp += 'Q'; else tmp += '.'; &#125; input.push_back(tmp); &#125; func(0, n, used, res); return res;&#125; 比第一次写得简洁一些 LeetCode练习题 Sudoku Solver 被京东的面试虐过 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;char&gt;&gt; res;template&lt;typename T&gt;void print2DBoard(vector&lt;vector&lt;T&gt;&gt; board) &#123; int i = 0; int j = 0; for (auto v1 : board) &#123; for (auto v2 : v1) &#123; cout &lt;&lt; v2 &lt;&lt; ' '; if (++j % 3 == 0) cout &lt;&lt; "| "; &#125; j = 0; cout &lt;&lt; endl; if (++i % 3 == 0) cout &lt;&lt; "-----------------------" &lt;&lt; endl;; &#125; cout &lt;&lt; endl;&#125;template&lt;typename T&gt;void print2DVector(vector&lt;vector&lt;T&gt;&gt; board) &#123; for (auto v1 : board) &#123; for (auto v2 : v1) &#123; cout &lt;&lt; v2 &lt;&lt; '\t'; &#125; cout &lt;&lt; endl &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void func(int i, int j, vector&lt;vector&lt;bool&gt;&gt;&amp; row, vector&lt;vector&lt;bool&gt;&gt;&amp; col, vector&lt;vector&lt;bool&gt;&gt;&amp; grid, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (i == 9) &#123; res = board; return; &#125; if (board[i][j] == '.') &#123; for (int k = 0; k &lt; 9; k++) &#123; if (row[i][k] == false &amp;&amp; col[j][k] == false &amp;&amp; grid[(i / 3) * 3 + j / 3][k] == false) &#123; board[i][j] = k + '1'; row[i][k] = true; col[j][k] = true; grid[(i / 3) * 3 + j / 3][k] = true; func((i + (j + 1) / 9), (j + 1) % 9, row, col, grid, board); grid[(i / 3) * 3 + j / 3][k] = false; col[j][k] = false; row[i][k] = false; board[i][j] = '.'; &#125; &#125; &#125; else &#123; func((i + (j + 1) / 9), (j + 1) % 9, row, col, grid, board); &#125;&#125;void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;vector&lt;bool&gt;&gt; row(9, vector&lt;bool&gt;(9, false)); vector&lt;vector&lt;bool&gt;&gt; col(9, vector&lt;bool&gt;(9, false)); vector&lt;vector&lt;bool&gt;&gt; grid(9, vector&lt;bool&gt;(9, false)); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; int num = board[i][j] - '0'; row[i][num - 1] = true; col[j][num - 1] = true; grid[(i / 3) * 3 + j / 3][num - 1] = true; &#125; &#125; &#125; //cout &lt;&lt; "print row" &lt;&lt; endl &lt;&lt; "-----------------------" &lt;&lt; endl; //print2DVector(row); //cout &lt;&lt; "print col" &lt;&lt; endl &lt;&lt; "-----------------------" &lt;&lt; endl; //print2DVector(col); //cout &lt;&lt; "print grid" &lt;&lt; endl &lt;&lt; "-----------------------" &lt;&lt; endl; //print2DVector(grid); func(0, 0, row, col, grid, board); board = res; //print2DBoard(board);&#125;int main() &#123; vector&lt;vector&lt;char&gt;&gt; input; string str[9] = &#123; "..9748...", "7........", ".2.1.9...", "..7...24.", ".64.1.59.", ".98...3..", "...8.3.2.", "........6", "...2759.." &#125;; for (auto s : str) &#123; input.push_back(vector&lt;char&gt;(s.begin(), s.end())); &#125; print2DBoard(input); solveSudoku(input); print2DBoard(res); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Binary Tree & Recursion]]></title>
      <url>%2F2017%2F10%2F07%2FBinary-Tree-Recursion%2F</url>
      <content type="text"><![CDATA[二叉树天然有着递归的结构，二叉树的定义即使用了递归123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 例题：二叉树的最大深度1234int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; return max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; LeetCode练习题No.111 Minimum Depth of Binary Tree Description:Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 坑：路径的定义是根节点到叶子节点，叶子节点是没有左右孩子的节点12345678910class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) return 1; else if (root -&gt; left &amp;&amp; root -&gt; right == NULL) return minDepth(root -&gt; left) + 1; else if (root -&gt; left == NULL &amp;&amp; root -&gt; right) return minDepth(root -&gt; right) + 1; else return min(minDepth(root -&gt; left), minDepth(root -&gt; right)) + 1; &#125;&#125;; 例题： 翻转二叉树12345678TreeNode* invertTree(TreeNode* root) &#123; if (root) &#123; TreeNode *left = invertTree(root -&gt; left); root -&gt; left = invertTree(root -&gt; right); root -&gt; right = left; &#125; return root;&#125; LeetCode练习题： No.100 SameTree No.101 Symmetric Tree No.222 Count Complete Tree Nodes No.110 Balanced Binary Tree 递归的终止条件例题: Path Sum 坑：还在叶子节点 12345678bool hasPathSum(TreeNode* root, int sum) &#123; //if (root == NULL) return (sum == 0); if (root == NULL) return false; if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) return (sum == root -&gt; val); return hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val);&#125; LeetCode练习题： No.404 Sum of Left Leaves 12345678int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; if (root -&gt; left != NULL &amp;&amp; root -&gt; left -&gt; left == NULL &amp;&amp; root -&gt; left -&gt; right == NULL) return root -&gt; left -&gt; val + sumOfLeftLeaves(root -&gt; right); else &#123; return sumOfLeftLeaves(root -&gt; left) + sumOfLeftLeaves(root -&gt; right); &#125;&#125; 递归的返回值例题：257. Binary Tree Paths 1234567891011121314vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;string&gt; res; string tmp = to_string(root -&gt; val); if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) res.push_back(tmp); vector&lt;string&gt; left = binaryTreePaths(root -&gt; left); for (auto iter = left.begin(); iter != left.end(); iter ++) res.push_back(tmp + "-&gt;" + *(iter)); vector&lt;string&gt; right = binaryTreePaths(root -&gt; right); for (auto iter = right.begin(); iter != right.end(); iter ++) res.push_back(tmp + "-&gt;" + *(iter)); return res;&#125; LeetCode练习题： No.113 Path Sum II 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSumHelper(TreeNode* root, int sum) &#123; if (root == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL) &#123; if (sum == root -&gt; val) res.push_back(&#123;sum&#125;); return res; &#125; int newSum = sum - root -&gt; val; vector&lt;vector&lt;int&gt;&gt; left = pathSumHelper(root -&gt; left, newSum); for (auto &amp;v: left) &#123; if (!v.empty()) &#123; v.push_back(root -&gt; val); res.push_back(v); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; right = pathSumHelper(root -&gt; right, newSum); for (auto &amp;v: right) &#123; if (!v.empty()) &#123; v.push_back(root -&gt; val); res.push_back(v); &#125; &#125; return res; &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res = pathSumHelper(root, sum); for (auto &amp;v: res) &#123; reverse(v.begin(), v.end()); &#125; return res; &#125;&#125;; No.129 Sum Root to Leaf Numbers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int str2num(string s) &#123; int res = 0; for(int i = 0; i &lt; s.size(); i++) &#123; res = res * 10 + s[i] - '0'; &#125; return res; &#125; vector&lt;string&gt; sumNumbersHelper(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;string&gt; res; string s_val = to_string(root -&gt; val); if (root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL)&#123; res.push_back(s_val); &#125; vector&lt;string&gt; left = sumNumbersHelper(root -&gt; left); for (auto &amp;s: left) &#123; res.push_back(s_val + s); &#125; vector&lt;string&gt; right = sumNumbersHelper(root -&gt; right); for (auto &amp;s: right) &#123; res.push_back(s_val + s); &#125; return res; &#125; int sumNumbers(TreeNode* root) &#123; vector&lt;string&gt; str_num = sumNumbersHelper(root); int res = 0; for (auto s : str_num) &#123; int tmp = str2num(s); res += tmp; &#125; return res; &#125;&#125;;//下面这个更值得学习class Solution &#123;public: int helper(TreeNode* root, int val) &#123; if (!root) return 0; auto v = val*10 + root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right) return v; return helper(root-&gt;left, v) + helper(root-&gt;right, v); &#125; int sumNumbers(TreeNode* root) &#123; return helper(root, 0); &#125;&#125;; 复杂递归问题 123456789101112131415161718192021222324252627282930313233343536373839404142//一种错误的做法int pathSumIII(TreeNode* root, int sum) &#123; return func(root, sum);&#125; int func(TreeNode* root, int sum) &#123; int count = 0; if (root == NULL) &#123; return (sum == 0) ? 1 : 0; &#125; if (sum == root -&gt; val) &#123; count += 1; &#125; count += func(root -&gt; left, sum - root -&gt; val) + func(root -&gt; right, sum - root -&gt; val); count += func(root -&gt; left, sum) + func(root -&gt; right, sum); //在递归中会重复计算这一个过程 return count; &#125; //正确的做法class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if (root == NULL) return 0; int count = 0; count += func(root, sum); count += pathSum(root -&gt; left, sum) + pathSum(root -&gt; right, sum); return count; &#125; int func(TreeNode* root, int sum) &#123; int count = 0; if (root == NULL) return 0; if (sum == root -&gt; val) count += 1; count += func(root -&gt; left, sum - root -&gt; val) + func(root -&gt; right, sum - root -&gt; val); return count; &#125; &#125;; 二分搜索树(Binary Search Tree) 基本操作： 插入(insert)查找(find)删除(delete) 实现的功能： 最大、最小前驱、后继上界、下界某个元素的排序寻找第K大(小)元素 用途：map，set数据库底层实现：平衡二分搜索树 例题： No.235 Lowest Common Ancestor of a Binary Search Tree 123456TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; if (p -&gt; val &lt; root -&gt; val &amp;&amp; q -&gt; val &lt; root -&gt; val) return lowestCommonAncestor(root -&gt; left, p, q); if (p -&gt; val &gt; root -&gt; val &amp;&amp; q -&gt; val &gt; root -&gt; val) return lowestCommonAncestor(root -&gt; right, p, q); return root;&#125; 此题引申到普通二叉树，以下代码在LeetCode上通过(速度感人)1234567891011TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; if (findTreeNode(root -&gt; left, p) &amp;&amp; findTreeNode(root -&gt; left, q)) return lowestCommonAncestor(root -&gt; left, p, q); if (findTreeNode(root -&gt; right, p) &amp;&amp; findTreeNode(root -&gt; right, q)) return lowestCommonAncestor(root -&gt; right, p, q); return root;&#125;bool findTreeNode(TreeNode* root, TreeNode* node) &#123; if (root == NULL) return false; if (root == node) return true; return findTreeNode(root -&gt; left, node) || findTreeNode(root -&gt; right, node);&#125; LeetCode练习题： No.98 Validate Binary Search Tree No.450 Delete Node in a BST No.108 Convert Sorted Array to Binary Search Tree No.230 Kth Smallest Elemment in a BST No.236 Lowest Common Ancestor of a Binary Tree12345678TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; if (root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root -&gt; left, p, q); TreeNode* right = lowestCommonAncestor(root -&gt; right, p, q); if (left &amp;&amp; right) return root; return left? left : right;&#125; 总结：跟叶子节点相关的问题，需要判断其左右子节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[笔试常用命令以及注意事项]]></title>
      <url>%2F2017%2F10%2F07%2F%E7%AC%94%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[又是一篇抄袭Vincent的博客，主要整理了笔试中常见容器的用法 vector 容器类的使用元素的访问123456789101112131415// 迭代器的方式（可以防止越界）vector&lt;int&gt; ::iterator iter = record.begin(); // 定义迭代器for (; iter != record.end(); iter++) cout &lt;&lt; *iter &lt;&lt; " ";cout &lt;&lt; endl;// 像数组一样的下标法访问，注意是否越界vector&lt;int&gt; record(&#123; 1, 2, 3, 4, 5 &#125;);for (int i=0; i &lt; record.size() ; i++) cout &lt;&lt; record[i] &lt;&lt; " ";cout &lt;&lt; endl;// 首尾元素int first=record.front(); // 首int last=record.back(); // 尾 赋值 初始化vector元素 12// 在record中放100个1vector&lt;int&gt; record(100,1); 输入单个元素 12345678910vector&lt;int&gt; record; // 没有定义record的大小int input;cin &gt;&gt;input;record.push_back(input); // 在record末尾追加input元素// 注意：此时不能利用下标法进行赋值，即record[0]=input是错误的！// 如果就是想用下标法赋值的话，必须指定vector的长度，即：vector&lt;int&gt; record(1); // 没有定义record的大小int input;cin &gt;&gt;input;record[0]=input; // 在record末尾追加input元素 将==输入的数字==传入一个已有的==vector== 1234// 输入a b c ,传入vector int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; // 输入a b cvector&lt;int&gt; record(&#123;a,b,c&#125;); 将一个==vector==中的一个==区间==赋值给另外一个==vector== 123456789101112131415// 将已知的input的位置区间[i,j)，即将从第i个位置到第j个位置之间的值传入到record vector&lt;int&gt; input(&#123;1,2,3,4,5,6,7,8&#125;);// 将区间[3,7)传入另一vectorvector&lt;int&gt; record(input.begin()+3-1,input.begin()+7-1);// 也可以用其成员函数assign命令，将区间[i,j)内的数据赋值给另外一个vectorvector&lt;int&gt; record；record.assign(input.begin(),input.end());// 特殊地，将input全部元素赋值给recordvector&lt;int&gt; record(input.begin() , input.end());// 或者使用vector的成员函数swap来交换两个vector的值vector&lt;int&gt; record; record.swap(input); // 将input赋值到record 将一个==数组==赋值给另外一个==vector== 1234// 将数组arr 传入record int arr[] = &#123; 1, 2, 3, 4, 5 &#125;;// 在vector变量的参数中，第一个是起始地址，第二个为终止地址vector&lt;int&gt; record(arr, arr + sizeof(arr)/sizeof(arr[0])); 插入 insert成员函数 123456789vector&lt;int&gt; record= &#123; 1, 2, 3, 4, 5 &#125;;// 在第2位（从第0位开始）插入100，也就是在2后面record.insert(record.begin()+2,100); //输出：1 2 100 3 4 5// record.insert(record+pos,c.begin(),c.end())在pos位插入c的全部元素vector&lt;int&gt; record = &#123; 1, 2, 3, 4, 5 &#125;;vector&lt;int&gt; a(&#123; 5, 2, 7, 8, 1, 0, 4 &#125;);record.insert(record.begin() + 1, a.begin(), a.end()); // 输出1 5 2 7 8 1 0 4 2 3 4 5 排序 对vector进行排序：==std::sort==的使用 12345// 将input复制到input_copy，然后对input_copy中的元素做排序处理vector&lt;int&gt; input(&#123; 2, 7, 4, 5, 1, 9, 3, 10, 6 &#125;);vector&lt;int&gt; input_copy(input.begin() , input.end()); // 这里的排序是就地排序，会改变原来数组的位置关系sort(input_copy.begin(), input_copy.end()); 统计 在vector中统计特定元素出现的次数：==std::count==的使用 123456// 统计record中出现7的次数vector&lt;int&gt; input(&#123; 2, 7, 1, 1, 1, 1, 4, 5, 1, 9, 7, 10, 6 &#125;);vector&lt;int&gt; record(input.begin() , input.end());// count是stl的标准函数，其参数是count(begin,end,value)int times = count(record.begin(), record.end(), 7);cout &lt;&lt; times &lt;&lt; endl; // 最后会输出 2 查找 在vector中查找是否出现了某个元素：==std::find==的使用 1234567// 判断record中是否出现8vector&lt;int&gt; input(&#123; 2, 7, 1, 1, 1, 1, 4, 5, 1, 9, 7, 10, 6 &#125;);vector&lt;int&gt; record(input.begin() , input.end()); // 赋值给record// 创建迭代器it，find是stl的标准函数，其参数是find(begin,end,value)vector&lt;int&gt; ::iterator it = find(record.begin(), record.end(), 8);if (it != tmp.end()) cout &lt;&lt; "found it !" &lt;&lt; endl;else cout &lt;&lt; "404 not found !" &lt;&lt; endl; map容器类的使用map就是所谓的映射，表示了从key-&gt;value的映射关系，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。 注意：unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序。 123456789101112131415161718map&lt;string, int&gt;::iterator it; //unordered_mapmap&lt;string, int&gt; record;record.insert(make_pair("c", 6));record.insert(make_pair("b", 66));record.insert(make_pair("a", 666));for (it = record.begin(); it != record.end(); ++it) cout &lt;&lt; "key: " &lt;&lt; it-&gt;first &lt;&lt; " value: " &lt;&lt; it-&gt;second &lt;&lt; endl; // 此时输出:// key: a value: 666// key: b value: 66// key: c value: 6//将初始化时的map换成unordered_map,// key: c value: 6// key: b value: 66// key: a value: 666 map的初始化 maprecord; 其中type1/2表示类型， 12345map&lt;int, vector&lt;int&gt;&gt; record;vector&lt;int &gt; value = &#123; 5, 2, 7, 8, 1, 0, 4 &#125;;record.insert(pair&lt;int, vector&lt;int&gt;&gt;(1, value));record.insert(pair&lt;int, vector&lt;int&gt;&gt;(2, &#123;4,5&#125;));record.insert(pair&lt;int, vector&lt;int&gt;&gt;(3, &#123;7,3,9,2&#125;)); 注意：上述初始化利用了pair来创建数据对， 在创建时需要指定类型。我们也可以用==make_pair==来简化这一步骤，make_pair():无需写出型别， 就可以生成一个pair对象 。 1234map&lt;int, vector&lt;int&gt;&gt; record;record.insert(make_pair(1, &#123; 5, 2, 7, 8, 1, 0, 4 &#125;));record.insert(make_pair(2, &#123;4,5&#125;));record.insert(make_pair(3, &#123;7,3,9,2&#125;)); map元素的访问 访问普通数组的方式来访问map；不过此时的key值应为int型 12345678cout &lt;&lt; record.size() &lt;&lt; endl; // 继续上述初始化的recordfor (int i = 0; i &lt; record.size(); i++)&#123; vector&lt;int&gt; temp = record[i]; for (int j = 0; j &lt; temp1.size(); j++) cout &lt;&lt; temp[j] &lt;&lt; " "; cout &lt;&lt; endl;&#125; 迭代器方式（任何） 123456789map&lt;int,int&gt;::iterator it;map&lt;int, int&gt; record;record.insert(pair&lt;int, int&gt;(1, 100));record.insert(pair&lt;int, int&gt;(2, 200));record.insert(pair&lt;int, itn&gt;(3, 300));for(it=record.begin();it!=record.end();++it) cout&lt;&lt;"key: "&lt;&lt;it-&gt;first &lt;&lt;" value: "&lt;&lt;it-&gt;second&lt;&lt;endl; 查找：find()对于容器们set，map以及相应的unordered_set或者unordered_map都有该成员函数。例如对于一个unordered_map类型的变量record。 12345unordered_map&lt;int,int&gt; record;if(record.find(key)!=record.end()) // 找到该建值&#123; ...&#125; 栈的使用stack var; // 声明一个type_name类型的var 常用的命令包括 12var.pop(); // 出栈var.push(); // 入栈 位运算n&amp;1和n%2是一个意思 参考vector容器类 在线IDE]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ListNode]]></title>
      <url>%2F2017%2F10%2F06%2FListNode%2F</url>
      <content type="text"><![CDATA[链表 反转 删重 No.92 Reverse Linked List II No.83 Remove Duplicates from Sorted List No.86 Parition List No.328 Odd Even Linked List No.2 Add Two Numbers No.455 Add Two Numbers II No.82 Remove Duplicates from Sorted List II No.21 Merge Two Sorted Lists No.25 Reverse Nodes in k-Group 双索引 No.61 Rotate List No.143 Reorder List No.234 Palindrome Linked List 排序 No.147 Insertion Sort List No.148 Sort List(归并排序)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo优化实验]]></title>
      <url>%2F2017%2F10%2F06%2FHexo%E4%BC%98%E5%8C%96%E5%AE%9E%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[用于记录不知道怎么优化的问题，和记录被改过的部分。 以下是希望有的功能，但是目前还不知道如何实现 [x] 去掉图片周围的边框进入目录themes\next\source\css\_common\components\post，打开文件post-expand.styl，搜索找到img，修改变量border后面的颜色编码，原是#ddd，改完之后是#FFF [ ] 图片不用总是居中显示 [ ] 代码折叠 [ ] 多选择流程图绘画 [ ] 复选框功能 修改了折叠样式在themes\next\source\css\_common\components\pages\schedule.styl中增加了一部分代码，使得在about页面可以隐藏一份简历，代码如下： 12345678910111213/*自定义图标，可用图片或字符,如果使用图片，请把content的值设置成空字符*//*展开*/.menu summary:before &#123; content: "--"; /*background: url(../Images/right.png) no-repeat center center;*/ /*收起时的图片*/ /*vertical-align: middle;*/&#125;/*收起*/.menu[open] summary:before &#123; content: "--"; /*background: url(../Images/down.png) no-repeat center center;*/ /*展开时的图片*/&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sort Algorithm]]></title>
      <url>%2F2017%2F09%2F30%2FSort-Algorithm%2F</url>
      <content type="text"><![CDATA[以下内容并非本人全部原创，主要来自以下博客（如果有侵犯其他人权益，你找他们就行）： 八大排序算法 常用排序算法总结(一) 概述 内部排序：数据记录在内存中排序 外部排序：内存不够用的情况下借助外存的排序 排序的种类 八大排序 插入排序 直接插入排序 希尔排序 选择排序 简单选择排序 堆排序 交换排序 快速排序 冒泡排序 基数排序(桶排序) 归并排序 时间复杂度nlog(n)的算法：快速排序，堆排序，归并排序；在数据量大的时候，快速排序是目前公认的最好的排序算法，数据顺序越混乱平均时间越短，是非稳定排序 复杂度分析 插入排序插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 具体算法描述： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 直接插入排序 要点：设立哨兵，用于临时存储和判断边界 示例： 1234567891011121314void insertSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int piv = nums[i]; int j = i - 1; // nums[j] &gt; piv 保证了排序是稳定的 while (j &gt;= 0 &amp;&amp; nums[j] &gt; piv) &#123; nums[j + 1] = nums[j]; j --; &#125; nums[j + 1] = piv; &#125;&#125; 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 二分插入在查找时，使用二分查找，减少查找的时间 12345678910111213141516171819202122void insertSortBin(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int piv = nums[i]; int left = 0; int right = i - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (mid &lt; piv) &#123; left = mid + 1; &#125; if (mid &gt; piv) &#123; right = mid - 1; &#125; &#125; for (int j = i - 1; j &gt;= left; j--) &#123; nums[j + 1] = nums[j]; &#125; nums[left] = piv; &#125;&#125; 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。 希尔排序希尔排序又叫缩小增量排序 示例： 123456789101112131415161718192021void shellInsertSort(vector&lt;int&gt;&amp; nums, int dk) &#123; int n = nums.size(); for (int i = dk; i &lt; n; i ++) &#123; int piv = nums[i]; int j = i - dk; while (j &gt;= 0 &amp;&amp; nums[j] &gt; piv) &#123; nums[j + dk] = nums[j]; j -= dk; &#125; nums[j + dk] = piv; &#125;&#125;void shellSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); dk = n / 2; while (dk) &#123; shellInsertSort(nums, dk); dk / 2; &#125;&#125; 希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。 选择排序选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。 简单选择排序基本思想：依次选出最小的数与排列靠前的数交换 示例： 123456789101112131415void selectSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i ++) &#123; int k = i; for (int j = i + 1; j &lt; n; j ++) &#123; if (nums[j] &lt; nums[k]) k = j; &#125; if (k != i) &#123; int tmp = nums[k]; nums[k] = nums[i]; nums[i] = tmp; &#125; &#125;&#125; 改进——二元选择排序 123456789101112131415161718192021void selectionSortTwo(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int left = 0; int right = n - 1; for (int i = 0; i &lt; n / 2; i ++) &#123; int min = left, max = left; for (int j = left + 1; j &lt;= right; j++) &#123; if (nums[j] &gt; nums[max]) max = j; if (nums[j] &lt; nums[min]) min = j; &#125; int tmp = nums[right]; nums[right] = nums[max]; nums[max] = tmp; right --; tmp = nums[left]; nums[left] = nums[min]; nums[min] = tmp; left ++; &#125;&#125; 堆排序两个过程：建堆+取堆顶后重建 建堆示例： 取堆顶后重建示例： 1234567891011121314151617181920212223242526272829303132//最大堆void adHeap(vector&lt;int&gt;&amp; nums, int pos, int n) &#123; int child = pos * 2 + 1; //int n = nums.size(); while (child &lt; n) &#123; int tmp = nums[pos]; if (child + 1 &lt; n &amp;&amp; nums[child] &lt; nums[child + 1]) ++ child; if (nums[child] &gt; nums[pos]) &#123; nums[pos] = nums[child]; pos = child; child = 2 * s + 1; &#125; else break; nums[pos] = tmp; &#125;&#125;void bulidHeap(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; -- i) &#123; adHeap(nums, i); &#125;&#125;void heapSort(vector&lt;int&gt;&amp; nums) &#123; for (int i = nums.size() - 1; i &gt;= 0; i --) &#123; int tmp = nums[i]; nums[i] = nums[0]; nums[0] = tmp; adHeap(nums, 0, i + 1); &#125;&#125; 设树的深度为k,\ ( k = \lfloor log_2n \rfloor + 1)。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式： 2(\lfloor log_2(n - 1) \rfloor + \lfloor log_2(n - 2) \rfloor + \cdots + log_22) < 2n\cdot\lfloor log_2n \rfloor 交换排序冒泡排序 两两比较，发现小号，往上冒泡 示例： 123456789101112void bubbleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; for (int i = n; i &gt;= 0; -- i) &#123; for (int j = n; j &gt;= i + 1; -- j) &#123; if (nums[j - 1] &gt; nums[j]) &#123; int tmp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = tmp; &#125; &#125; &#125;&#125; 冒泡改进123456789101112131415void bubbleSort_1(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size() - 1; while(n &gt; 0) &#123; int pos = 0; for (int j = 0; j &lt; n; j ++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; pos = j; int tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; &#125; &#125; n = pos; &#125;&#125; 鸡尾酒排序双向冒泡1234567891011121314151617181920212223void cockTailSort(vector&lt;int&gt;&amp; nums) &#123; int left = 0; int right = nums.size() - 1; while (left &lt; right) &#123; for (int i = left; i &lt; right; i ++) &#123; if (A[i] &gt; A[i + 1]) &#123; int tmp = A[i]; A[i] = A[i + 1]; A[i + 1] = tmp; &#125; &#125; right --; for (int i = right; i &gt; left; i --) &#123; if (A[i - 1] &gt; A[i]) &#123; int tmp = A[i - 1]; A[i - 1] = A[i]; A[i] = A[i - 1]; &#125; &#125; left ++; &#125;&#125; 快速排序快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为： 从序列中挑出一个元素，作为”基准”(pivot). 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。 12345678910111213141516171819202122232425void quickSort(vector&lt;int&gt;&amp; nums, int i, int j) &#123; int piv = nums[left]; int left = i; int idx = i; int right = j; while(i &lt; j) &#123; while(j &gt; i &amp;&amp; piv &lt; nums[j]) &#123; j --; &#125; if (j &gt; i) &#123; nums[i] = nums[j]; &#125; while(i &lt; j &amp;&amp; piv &gt; nums[i]) &#123; i ++; &#125; if (i &lt; j) &#123; nums[j] = nums[i]; &#125; &#125; nums[i] = piv; quickSort(nums, left, i - 1); quickSort(nums, i + 1, right); &#125; 快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。 比如序列：{1, 3, 4, 2, 8, 9, 8, 7, 5}，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。 基数排序基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)实例: 扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为： 花色： 梅花&lt; 方块&lt; 红心&lt; 黑心面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A 若对扑克牌按花色、面值进行升序排序，得到如下序列： 即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。 为得到排序结果，我们讨论两种排序方法。 方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。 方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。 设n 个元素的待排序列包含d 个关键码{k_1, k_2, \cdots, k_d}，则称序列对关键码${k_1, k_2, \cdots, k_d}$有序是指：对于序列中任两个记录r[i]和r[j](1≤i≤j≤n)都满足下列有序关系： (k_i^1, k_i^2, \cdots, k_i^d) < (k_j^1, k_j^2, \cdots, k_j^d)其中k_1 称为最主位关键码，k_d 称为最次位关键码。 两种多关键码排序方法： 多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法： 最高位优先(Most Significant Digit first)法，简称MSD 法： 先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k_1相等。 再对各组按k_2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码k_d对各子组排序后。 再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。 最低位优先(Least Significant Digit first)法，简称LSD 法： 先从k_d 开始排序，再对k_{d-1}进行排序，依次重复，直到按k1排序分组分成最小的子序列后。 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。 基于LSD方法的链式基数排序的基本思想 “多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。 基数排序: 是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 归并排序归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。 归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// merge 函数void mergeFunc(vector&lt;int&gt;&amp; nums, int left, int mid, int right) &#123; int i = left; int j = mid + 1; int n = right - left + 1; vector&lt;int&gt; tmp(n, 0); int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (nums[i] &gt; nums[j]) &#123; tmp[k] = nums[j]; j ++; &#125; else &#123; tmp[k] = nums[i]; i ++; &#125; k ++; &#125; while (i &lt;= mid) &#123; tmp[k] = nums[i]; i ++; k ++; &#125; while (j &lt;= right) &#123; tmp[k] = nums[j]; j ++; k ++; &#125; nums(tmp.begin(), tmp.end());&#125;// 递归法void mergeSortRecursion(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left == right) return; int mid = (right - left) / 2; mergeSortRecursion(nums, left, mid); mergeSortRecursion(nums, mid + 1, right); mergeFunc(nums, left, mid, right);&#125;// 迭代法void mergeSortIter(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int left, right; for (int i = 1; i &lt; n; i *= 2) &#123; left = 0; while(left + i &lt; n) &#123; int mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1; mergeFunc(nums, left, mid, right); left = right + 1; &#125; &#125;&#125; 总结时间复杂度： 平方阶(O(n2))排序 各类简单排序:直接插入、直接选择和冒泡排序； 线性对数阶(O(nlog2n))排序 快速排序、堆排序和归并排序； O(n^{1+§})排序,§是介于0和1之间的常数。 希尔排序 线性阶(O(n))排序 基数排序，此外还有桶、箱排序。 说明： 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O(n)；而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O(n^2)；原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。 稳定性： 排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较； 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排 示意图shell排序 堆排序 冒泡排序 鸡尾酒排序 快速排序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Data Structure]]></title>
      <url>%2F2017%2F09%2F29%2FData-Structure%2F</url>
      <content type="text"><![CDATA[先作一个草稿集 排序详细请看 查找概述查找的种类1. 二分查找 2. hash查找 3. 树查找 4. 图查找 查找涉及的数据结构树和图 二分查找123456789101112int binarySearch(vector&lt;int&gt; nums, int target) &#123; int left = 0; int right = nums.size() - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; return -1;&#125; 查找LeetCode的练习题： 对撞指针 No.125 Valid Palindrome No.344 Reverse String No.345 Reverse Vowels of a string No.11 Container with Most water 滑动窗口 No.438 Find All Anagrams in a String No.76 Minimum Window Substring hash查找 set(集合)处理存在的问题map(字典)处理查找的问题 STL 底层实现 时间复杂度 map, set 平衡二叉树 O(log(n)) unordered_map, unordered_set 哈希表 O(1) LeetCode练习题： No.242 Valid Anagram No.202 Happy Number No.290 Word Pattern No.205 Isomorphic Strings No.451 Sort Characters By Frequency No.15 3Sum No.18 4Sum No.16 3Sum Closest No.49 Group Anagrams No.447 Number of Boomerangs No.149 Max Points on a Line 树的遍历深度优先遍历，一般考虑使用递归或者使用栈。 递归版本123456789101112131415161718192021222324252627282930struct TreeNode&#123; int val, TreeNode *right, TreeNode *left, TreeNode(int x) val(x), left(NULL), right(NULL) &#123;&#125;&#125;// **先序遍历**void preOrder(TreeNode *root) &#123; if (root) &#123; cout &lt;&lt; root -&gt; val &lt;&lt; endl; preOrder(root -&gt; left) &lt;&lt; endl; preOrder(root -&gt; right) &lt;&lt; endl; &#125;&#125;// **中序遍历**void inOrder(TreeNode *root) &#123; if (root) &#123; preOrder(root -&gt; left) &lt;&lt; endl; cout &lt;&lt; root -&gt; val &lt;&lt; endl; preOrder(root -&gt; right) &lt;&lt; endl; &#125;&#125;// **后序遍历**void preOrder(TreeNode *root) &#123; if (root) &#123; preOrder(root -&gt; left) &lt;&lt; endl; preOrder(root -&gt; right) &lt;&lt; endl; cout &lt;&lt; root -&gt; val &lt;&lt; endl; &#125;&#125; 非递归版本版本112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// **先序遍历**void PreOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); cout &lt;&lt; p -&gt; val &lt;&lt; endl; p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); p = p -&gt; right; &#125; &#125;&#125;//**中序遍历**void InOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); cout &lt;&lt; p -&gt; val &lt;&lt; endl; p = p -&gt; right; &#125; &#125; &#125;//**后序遍历**//这个是错的，这种思路下，后序遍历的写法差异很大void PostOrder(TreeNode* root) &#123;void InOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); if (! p -&gt; right) &#123; cout &lt;&lt; p -&gt; val &lt;&lt; endl; &#125; p = p -&gt; right; &#125; &#125; &#125; &#125; 版本21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct TreeNode &#123; int val, TreeNode *left, TreeNode *right, TreeNode(int x) val(x), left(NULL), right(NULL) &#123;&#125;&#125;struct Command &#123; string s, //两个状态go和print，go用于继续往下访问的状态，print用于输出当前节点的状态 TreeNode* node, Command(string s, TreeNode* node) s(s), node(node) &#123;&#125;&#125;//先序遍历void preOrder(TreeNode *root) &#123; stack&lt;Command&gt; stk; stk.push(Command("go", root)); while(!stk.empty()) &#123; Command tmp = stk.top(); stk.pop(); if (tmp.s == "print") cout &lt;&lt; tmp.node -&gt; val &lt;&lt; endl; else &#123; if (tmp.node -&gt; right) stk.push(Command("go", tmp.node -&gt; right)); if (tmp.node -&gt; left) stk.push(Command("go", tmp.node -&gt; left)); stk.push(Command("print", tmp.node)); &#125; &#125;&#125;//中序遍历void inOrder(TreeNode *root) &#123; stack&lt;Command&gt; stk; stk.push(Command("go", root)); while(!stk.empty()) &#123; Command tmp = stk.top(); stk.pop(); if (tmp.s == "print") cout &lt;&lt; tmp.node -&gt; val &lt;&lt; endl; else &#123; if (tmp.node -&gt; right) stk.push(Command("go", tmp.node -&gt; right)); stk.push(Command("print", tmp.node)); if (tmp.node -&gt; left) stk.push(Command("go", tmp.node -&gt; left)); &#125; &#125;&#125;//后序遍历void postOrder(TreeNode *root) &#123; stack&lt;Command&gt; stk; stk.push(Command("go", root)); while(!stk.empty()) &#123; Command tmp = stk.top(); stk.pop(); if (tmp.s == "print") cout &lt;&lt; tmp.node -&gt; val &lt;&lt; endl; else &#123; stk.push(Command("print", tmp.node)); if (tmp.node -&gt; right) stk.push(Command("go", tmp.node -&gt; right)); if (tmp.node -&gt; left) stk.push(Command("go", tmp.node -&gt; left)); &#125; &#125;&#125; 栈LeetCode的练习题： No.150 Evaluate Reverse Polish Notation No.11 Simplify Path 图的遍历广度优先遍历，考虑使用队列 层序遍历 无权图的最短路径 层序遍历123456789101112131415161718192021222324struct TreeNode &#123; int val, TreeNode *left, TreeNode *right, TreeNode(int x) val(x), left(NULL), right(NULL) &#123;&#125;&#125;vector&lt;vector&gt; levelOrder(TreeNode *root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;pair&lt;TreeNode*, int&gt;&gt; q; q.push(make_pair(root, 0)); while(!q.empty()) &#123; TreeNode *node = q.front().first; int level = q.front().second; q.pop(); if (level == res.size()) &#123; res.push_back(vector&lt;int&gt; ()); &#125; res[level].push_back(node -&gt; val); if (node -&gt; left) q.push(make_pair(node -&gt; left, level + 1)); if (node -&gt; right) q.push(make_pair(node -&gt; right, level + 1)); &#125; return res;&#125; 层序遍历LeetCode练习题： No.107 Binary Tree Level Order Traversal II No.103 Binary Tree ZigZag Level Order Traversal No.199 Binary Tree Right Side View 无权图最短路径以LeetCode的279题“Perfect Sqaure”为例，将问题转化为无权图路径问题123456789101112131415161718192021int numSquare(int n) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(make_pair(n, 0)); bool visited(n + 1, false); while(!q.empty()) &#123; int num = q.front().first(); int step = q.front().second(); q.pop(); int i = 1; int a = num - i * i; while (a &gt;= 0) &#123; if (a == 0) return step + 1; if (!visited[a]) &#123; q.push(make_pair(a, step + 1)); visited[a] = true; &#125; i ++; a = num - i * i; &#125; &#125;&#125; 无权图LeetCode练习： No.127 World Ladder No.126 World Ladder II 优先队列 和普通队列，栈相比 不同：不是从线性结构的头或尾出数据 同：是一种广义的队列，出最大的数或者最小的数 实现方式：堆 c++容器: priority_queue 优先队列实验12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;int main() &#123; srand(time(NULL)); priority_queue&lt;int&gt; pq;//默认是最大堆 //最小堆的声明，在VS2015中greater&lt;int&gt;报错 //priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; cout &lt;&lt; "insert: " &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; int num = rand() % 100; pq.push(num); cout &lt;&lt; num &lt;&lt; '\t'; &#125; cout &lt;&lt; endl; cout &lt;&lt; "pop: " &lt;&lt; endl; while (!pq.empty()) &#123; cout &lt;&lt; pq.top() &lt;&lt; '\t'; pq.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; 结果： LeetCode 347. Top K Frequent Elements给定一个非空数组，返回前k个出现频率最高的元素 1234567891011121314151617181920212223242526vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // table中(number, frequent) unordered_map&lt;int, int&gt; table; for (int i = 0; i &lt; nums.size(); i ++) &#123; table[nums[i]] ++; &#125; // pair中(frequent, number),因为需要对frequent进行排序 priority_queue&lt;pair&lt;int ,int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;) pq; for (auto iter = table.begin(); iter != table.end(); iter ++) &#123; if (pq.size() == k) &#123; // 频率与频率比较，最小堆的堆顶最小 if (iter -&gt; second &gt; pq.top() -&gt; first) &#123; pq.pop(); pq.push(make_pair(iter -&gt; second, iter -&gt; first)); &#125; continue; &#125; pq.push(make_pair(iter -&gt; second, iter -&gt; first)); &#125; vector&lt;int&gt; res; while(!pq.empty()) &#123; res.push_back(pq.top() -&gt; second()); pq.pop(); &#125; return res;&#125; 优先队列练习 No. 23. Merge k Sorted Lists]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode Backtracking]]></title>
      <url>%2F2017%2F09%2F21%2FLeetCode-Backtracking%2F</url>
      <content type="text"><![CDATA[Problems Lists What is Backtracking? Medium357. Count Numbers with Unique DigitsDescriptionGiven a non-negative integer n, count all numbers with unique digits, x, where $0 \le x &lt; 10^n$. Example:Given n = 2, return 91. (The answer should be the total numbers in the range of $0 \le x &lt; 100$, excluding [11,22,33,44,55,66,77,88,99]) Credits:Special thanks to @memoryless for adding this problem and creating all test cases. 解题思路：一个n位数并且每位数字不重复，总共有这么多个数字 f(n) = {A_{10}^n} - {A_{9}}^{n-1}设 f(0) = A_{10}^0 = 1然后累加。 1234567891011121314151617181920212223class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; if (n &lt; 0) return 0; if (n &gt; 10) n = 10; int result = 0; int tmp1 = 1; int tmp2 = 0; for (int i = 0; i &lt;= n; i++) &#123; result += tmp1 - tmp2; tmp1 *= 10 - i; if (i == 0) &#123; tmp2 = 1; &#125; else &#123; tmp2 *= 10 - i; &#125; &#125; return result; &#125;&#125;; 回溯方法 1234567891011121314151617181920212223242526class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; int res = 1, max = pow(10, n), used = 0; for (int i = 1; i &lt; 10; ++i) &#123; used |= (1 &lt;&lt; i); res += search(i, max, used); used &amp;= ~(1 &lt;&lt; i); &#125; return res; &#125; int search(int pre, int max, int used) &#123; int res = 0; if (pre &lt; max) ++res; else return res; for (int i = 0; i &lt; 10; ++i) &#123; if (!(used &amp; (1 &lt;&lt; i))) &#123; used |= (1 &lt;&lt; i); int cur = 10 * pre + i; res += search(cur, max, used); used &amp;= ~(1 &lt;&lt; i); &#125; &#125; return res; &#125;&#125;; bug版回溯123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; if (n &gt; 10) &#123; return countNumbersWithUniqueDigits(10); &#125; vector&lt;bool&gt; used(10, false); int count = 1; long max = pow(10, n); for (int i = 0; i &lt; 10; i++) &#123; used[i] = true; count += search(i, max, used); used[i] = false; &#125; return count; &#125; int search(long pre, long max, vector&lt;bool&gt;&amp; used) &#123; int count = 0; if (pre &lt; max) count++; else return count; for (int i = 0; i &lt; 10; i++) &#123; if (!used[i]) &#123; used[i] = true; long cur = 10 * pre + i; count += search(cur, max, used); used[i] = false; &#125; &#125; return count; &#125;&#125;; 22. Generate ParenthesesDescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 解题思路：合法字符串的任意位置，右括号数量不大于左括号数量。12345678910111213141516class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; func(n, n, "", res); return res; &#125; void func(int left, int right, string tmp, vector&lt;string&gt; &amp;res) &#123; if (left &gt; right) return; if (left ==0 &amp;&amp; right == 0) res.push_back(tmp); if (left &gt; 0) func(left - 1, right, tmp + '(', res); if (right &gt; 0) func(left, right - 1, tmp + ')', res); &#125;&#125;; 参考来源 216. Combination Sum IIIDescription： Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1: Input: k = 3, n = 7 Output:1[[1,2,4]] Example 2: Input: k = 3, n = 9 Output:1[[1,2,6], [1,3,5], [2,3,4]] Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. 解题思路：把已经算过的数放入一个向量中，在不满足条件的情况下，把值退出来；满足条件下，把最终结果保存 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(k, n, 1, tmp, res); return res; &#125; void func(int k, int n, int level, vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (n &lt; 0) return; if (n == 0 &amp;&amp; tmp.size() == k) res.push_back(tmp); for (int i = level; i &lt;= 9; i++) &#123; tmp.push_back(i); func(k, n - i, i + 1, tmp, res); //func(k, n - i, level + 1, tmp, res);//bug版本；也能输出，但是会出现重复数字 tmp.pop_back(); &#125; &#125;&#125;; 参考 46. PermutationsDescription： Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] ！！！这是宝宝写出来的第一个回溯算法题！！！解题思路：大循环【从nums中擦除一个数，在tmp中加入，然后把nums和tmp放到下一层递归；终止条件是当nums==0，tmp的大小和最初nums一样大时，查找tmp是否在结果中，如果在跳出，否则加入结果；然后把擦除的数插入回nums，tmp弹出这个数】123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(nums, tmp, res); return res; &#125; void func(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (nums.size() == 0 &amp;&amp; find(res.begin(), res.end(), tmp) != res.end()) return; if (nums.size() == 0 &amp;&amp; find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); for (auto iter = nums.begin(); iter != nums.end(); iter++) &#123; int val = *iter; tmp.push_back(val); nums.erase(iter); func(nums, tmp, res); nums.insert(iter, val); tmp.pop_back(); &#125; &#125;&#125;; 别人的解 89. Gray CodeDescription: The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 公式法：每个格雷码 = 当前二进制数 异或 （当前二进制数右移一位） 12345678910class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; pow(2, n); i++) &#123; res.push_back((i &gt;&gt; 1) ^ i); &#125; return res; &#125;&#125;; 镜像翻转法： 12345678910111213class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; res.push_back(0); for (int i = 0; i &lt; n; i++) &#123; for (int j = pow(2, i) - 1; j &gt;= 0; j--) &#123; res.push_back(res[j] | (1 &lt;&lt; i)); &#125; &#125; return res; &#125;&#125;; 回溯法，目前没搞明白……囧 回溯法1 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; unordered_set&lt;int&gt; s; helper(n, s, 0, res); return res; &#125; void helper(int n, unordered_set&lt;int&gt;&amp; s, int out, vector&lt;int&gt;&amp; res) &#123; if (!s.count(out)) &#123; s.insert(out); res.push_back(out); &#125; for (int i = 0; i &lt; n; ++i) &#123; int t = out; if ((t &amp; (1 &lt;&lt; i)) == 0) t |= (1 &lt;&lt; i); else t &amp;= ~(1 &lt;&lt; i); if (s.count(t)) continue; helper(n, s, t, res); break; &#125; &#125;&#125;; 回溯法21234567891011121314151617181920212223242526272829303132333435int conversion(int n)&#123; int temp=1; if(n==1) return 1; for(int i=1;i&lt;n;i++) temp=temp*2; return temp;&#125;vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result; if(n==0) &#123; result.push_back(0); return result; &#125; if(n==1) &#123; result.push_back(0); result.push_back(1); return result; &#125; else &#123; //queue&lt;int&gt; temp; result=grayCode(n-1); int len=result.size(); for(int i=len-1;i&gt;=0;--i) &#123; int temp=result[i]+conversion(n); result.push_back(temp); &#125; return result; &#125;&#125; 78. SubsetsDescription： Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路：12345678910 [] / \ / \ / \ [1] [] / \ / \ / \ / \ [1 2] [1] [2] [] / \ / \ / \ / \[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp = &#123;&#125;; func(0, tmp, res, nums); return res; &#125; void func(int pos, vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;nums) &#123; res.push_back(tmp); for (int i = pos; i &lt; nums.size(); i ++) &#123; tmp.push_back(nums[i]); func(i + 1, tmp, res, nums); tmp.pop_back(); &#125; &#125;&#125;; 77. CombinationsDescription:Given two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is:12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路：这题是组合情况，比之前的46题排列情况更简单一点 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; input; vector&lt;int&gt; tmp; for (int i = 1; i &lt;= n; i++) &#123; input.push_back(i); &#125; func(n, k, tmp, 0, res); return res; &#125; void func(int n, int k, vector&lt;int&gt; &amp;tmp, int pos, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (tmp.size() == k &amp;&amp; find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else if (tmp.size() == k) return; for (int i = pos; i &lt; n; i++) &#123; tmp.push_back(i + 1); func(n, k, tmp, i + 1, res); tmp.pop_back(); &#125; &#125;&#125;; 39. Combination SumDescription: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:1234[ [7], [2, 2, 3]] 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //int sum = 0; func(target, tmp, res, candidates); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates) &#123; int sum = 0; for (auto c: tmp) sum += c; if (sum &gt; target) return; else if (sum == target) &#123; vector&lt;int&gt; tmp2 =tmp; //一开始没有加tmp2变量，导致每次排序之后tmp.pop_back()改变原先内容 sort(tmp2.begin(), tmp2.end()); if (find(res.begin(), res.end(), tmp2) == res.end()) res.push_back(tmp2); else return; &#125; for (int i = 0; i &lt; candidates.size(); i++) &#123; tmp.push_back(candidates[i]); func(target, tmp, res, candidates); tmp.pop_back(); &#125; &#125;&#125;; faster123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //int sum = 0; func(target, tmp, res, candidates); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates) &#123; if (0 == target) &#123; vector&lt;int&gt; tmp2 =tmp; sort(tmp2.begin(), tmp2.end()); if (find(res.begin(), res.end(), tmp2) == res.end()) res.push_back(tmp2); else return; &#125; for (int i = 0; i &lt; candidates.size(); i++) &#123; if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(target - candidates[i], tmp, res, candidates); tmp.pop_back(); &#125; &#125; &#125;&#125;; more faster12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //sort(candidates.begin(), candidates.end()); func(target, tmp, res, candidates, 0); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates, int idx) &#123; if (0 == target) &#123; res.push_back(tmp); return; &#125; for (int i = idx; i &lt; candidates.size(); i++) &#123; //if(i&gt;idx &amp;&amp; candidates[i]==candidates[i-1]) continue; if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(target - candidates[i], tmp, res, candidates, i); tmp.pop_back(); &#125; &#125; &#125;&#125;; 90. Subsets IIDescription: Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is:12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路：此题与Subsets非常思路相同，只是在加入过程中多用了一个查找来判断重复，12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp = &#123;&#125;; sort(nums.begin(), nums.end()); int size = nums.size(); func(0, tmp, res, nums); return res; &#125; void func(int idx, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums) &#123; if (find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else return; for (int i = idx; i &lt;nums.size(); i++) &#123; tmp.push_back(nums[i]); func(i + 1, tmp, res, nums); tmp.pop_back(); &#125; &#125;&#125;; 17. Letter Combinations of a Phone NumberDescription： Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 解题思路：把这个问题构造成一个普通的回溯问题，差别在于一般回溯问题都是在一个向量上操作的，这个是在二维向量上操作，难点在于把二维向量构造出来，然后就可以了，不会存在重复和排序问题。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;char&gt;&gt; makeTable() &#123; //如果不看这个函数，代码还是挺简洁的 (=´ω｀=) vector&lt;vector&lt;char&gt;&gt; m; vector&lt;char&gt; tmp0 = &#123;'a', 'b', 'c'&#125;; m.push_back(tmp0); vector&lt;char&gt; tmp1 = &#123;'d', 'e', 'f'&#125;; m.push_back(tmp1); vector&lt;char&gt; tmp2 = &#123;'g', 'h', 'i'&#125;; m.push_back(tmp2); vector&lt;char&gt; tmp3 = &#123;'j', 'k', 'l'&#125;; m.push_back(tmp3); vector&lt;char&gt; tmp4 = &#123;'m', 'n', 'o'&#125;; m.push_back(tmp4); vector&lt;char&gt; tmp5 = &#123;'p', 'q', 'r', 's'&#125;; m.push_back(tmp5); vector&lt;char&gt; tmp6 = &#123;'t', 'u', 'v'&#125;; m.push_back(tmp6); vector&lt;char&gt; tmp7 = &#123;'w', 'x', 'y', 'z'&#125;; m.push_back(tmp7); return m; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return &#123;&#125;; vector&lt;vector&lt;char&gt;&gt; m = makeTable(); vector&lt;string&gt; res; string tmp = ""; func(tmp, 0, digits, m, res); return res; &#125; void func(string tmp, int idx, string digits, vector&lt;vector&lt;char&gt;&gt;&amp; m, vector&lt;string&gt;&amp; res) &#123; if (idx == digits.size()) res.push_back(tmp); int digits_i = digits[idx] - '2'; for (int i = 0; i &lt; m[digits_i].size(); i++) &#123; tmp += m[digits_i][i]; func(tmp, idx + 1, digits, m, res); tmp.pop_back(); &#125; &#125;&#125;; 40. Combination Sum IIDescription: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is:123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解题思路：这题是在Combination Sum基础上加了两个变化，一个是无序，另一个是重复数字，对应的策略也就是在Combination Sum中被我注释的两行(一开始是抄了人家的代码，没抄明白，发现注释了也能跑通，现在才大致知道作用是什么了) 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); func(0, target, tmp, candidates, res); return res; &#125; void func(int idx, int target, vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; //if (target &lt; 0) return; if (target == 0) res.push_back(tmp); for(int i = idx; i &lt; candidates.size(); i++) &#123; if (i &gt; idx &amp;&amp; candidates[i] == candidates[i - 1]) continue; //这句的作用在于，一个是让在这一层中，相同的数字不再继续往下找；第二，i &gt; idx 而不是 i &gt; 0是确保了从idx开始的数能够被保存进来 if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(i + 1, target - candidates[i], tmp, candidates, res); tmp.pop_back(); &#125; else return; //这句让效率从24%到85%，之所以能用，是因为candidates数组已经排序过，数组后面的数必然都不满足 &#125; &#125;&#125;; 131. Palindrome PartitioningDescription： Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = &quot;aab&quot;,Return1234[ ["aa","b"], ["a","a","b"]] 解题思路：思路很混乱， 第一，先有一个判断回文的函数；然后从前往后逐一取子集，如果当前字符是回文的则保存，并把后续的子字符串当做新字符串，依次迭代。有个难点是，边界问题。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool ispalindrome(string str) &#123; for (int i = 0, j = str.size() - 1; i &lt; j; i ++, j--) &#123; if (str[i] != str[j]) return false; &#125; return true; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; out; // string tmp; func("", s, out, res); return res; &#125; void func(string tmp, string str, vector&lt;string&gt;&amp; out, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (str.size() == 1) &#123; out.push_back(str); res.push_back(out); out.pop_back(); return; &#125; for (int i = 0; i &lt; str.size(); i++) &#123; tmp += str[i]; if (ispalindrome(tmp)) &#123; out.push_back(tmp); if (i == str.size() - 1) res.push_back(out); else func("", str.substr(i + 1, str.size() - i - 1), out, res); out.pop_back(); &#125; &#125; &#125;&#125;; 3ms大神的解法(我的是9ms)，代码非常简洁易懂，就是学不来。跟我的区别最大的是，他保存的是子串，往下传递的是坐标，方法上比较接近于普通的回溯。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; ret; vector&lt;string&gt; tmp; DFS(ret, tmp, s, 0); return ret; &#125; private: void DFS(vector&lt;vector&lt;string&gt;&gt;&amp; ret, vector&lt;string&gt;&amp; tmp, string&amp; s, int pos) &#123; if (pos == s.size()) &#123; ret.push_back(tmp); return; &#125; for (int i = pos; i &lt; s.size(); ++i) &#123; if(test(s, pos, i)) &#123; tmp.push_back(s.substr(pos, i-pos+1)); DFS(ret, tmp, s, i+1); tmp.pop_back(); &#125; &#125; &#125; bool test(string&amp; str, int start, int end) //检查函数 &#123; while (start &lt; end &amp;&amp; str[start] == str[end]) &#123; ++start; --end; &#125; return (start &gt;= end); &#125;&#125;; 47. Permutations IIDescription： Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations:12345[ [1,1,2], [1,2,1], [2,1,1]] 解题思路：这题在没有1,2两句的情况下，一直受到时间限制的困扰，加上之后就能通过。12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; //vector&lt;int&gt; used(nums.size(), 0); int size = nums.size(); sort(nums.begin(), nums.end()); //1 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(tmp, res, size, nums); return res; &#125; void func(vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int size, vector&lt;int&gt;&amp; nums) &#123; if (tmp.size() == size) &#123; if (find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else return; &#125; for (auto iter = nums.begin(); iter != nums.end(); iter++) &#123; //if (used[i] == 0) &#123; //used[i] = 1; if (iter &gt; nums.begin() &amp;&amp; *iter == *(iter - 1)) continue; //2 在排序之后相等的数字连续出现，重复数字不再进入下层递归，减小了时间复杂度。 int val = *iter; tmp.push_back(val); nums.erase(iter); func(tmp, res, size, nums); nums.insert(iter, val); tmp.pop_back(); //used[i] = 0; //&#125; &#125; &#125;&#125;; 目前LeetCode上最快的解，学习无能Orz12345678910111213141516171819202122232425262728class Solution &#123;public: void myPermute(vector&lt;int&gt; nums, int start, vector&lt;vector &lt;int&gt;&gt;&amp; result) &#123; int length = nums.size(); if (start == length) &#123; result.push_back(nums); // cout &lt;&lt; per[1] &lt;&lt; per[2] &lt;&lt; per[3] &lt;&lt; endl; return; &#125; for (int i = start; i &lt; length; i++) &#123; if (i != start &amp;&amp; nums[i] == nums[start]) continue; swap(nums[i], nums[start]); myPermute(nums, start + 1, result); // swap(nums[i], nums[start]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int length = nums.size(); vector&lt;vector &lt;int&gt;&gt; result; myPermute(nums, 0, result); return result; &#125;&#125;; 60. Permutation SequenceDescription： The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3):123456"123""132""213""231""312""321" Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 解题思路：如果用Permutations的思路来做的话，会超时。可以发现排序的数字仅看第一位，总是按照1, 2 , 3 ,..., n，这样的顺序排列的，然后看第一位之后的排序方式有A_{n-1}^{n-1}，也就是以1打头的数字排在[0,\ A_{n-1}^{n-1}]之间，以2打头的数字排在[A_{n-1}^{n-1} + 1,\ 2 \times A_{n-1}^{n-1}]，以x打头的数字排在[(x - 1) \times A_{n-1}^{n-1} + 1,\ x \times A_{n-1}^{n-1}]之间。确定第一个数字之后，后面的序列排在第k = k - (x - 1) \times A_{n-1}^{n-1}个，往下依次类推。1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string getPermutation(int n, int k) &#123; string res = ""; vector&lt;int&gt; nums; for (int i = 1; i &lt;= n; i++) nums.push_back(i); int a = cntFunc(n - 1); func(res, k, n, a, nums); return res; &#125; int cntFunc(int n) &#123; if (n &lt;= 0) return 1; int res = 1; for (int i = 1; i &lt;= n; i ++) res *= i; return res; &#125; void func(string&amp; res, int k, int n, int a, vector&lt;int&gt;&amp; nums) &#123; if (n == 0) return; //int a = cntFunc(n - 1); int i = 0; for (auto iter = nums.begin(); iter != nums.end(); iter ++, i++) &#123; if ((i * a &lt; k) &amp;&amp; ((i + 1) * a &gt;= k)) &#123; //通过条件来剪枝，否则会超时 int val = *iter; res += val + '0'; if (n &gt; 1) &#123; nums.erase(iter); //这种操作在VS2015上会报错 func(res, k - (i * a), n - 1, a / (n - 1), nums); nums.insert(iter, val); &#125; else break; &#125; &#125; &#125;&#125;; 93. Restore IP AddressesDescription: Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example:Given &quot;25525511135&quot;, return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) 解题思路：用一个函数判断字符串是否合法，然后就是回溯 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; if(s.size() &gt; 4 * 3 || s.size() &lt; 4) return &#123;&#125;; //减少无效字符输入 vector&lt;string&gt; res; func(0, 4, "", res, s); return res; &#125; void func(int start, int part, string out, vector&lt;string&gt;&amp; res, string s) &#123; if (start == s.size() &amp;&amp; part == 0) &#123; out.pop_back(); res.push_back(out); &#125; for (int i = start, j = 1; i &lt; s.size(); i++, j++) &#123; if (j &gt; 3) return; string tmp = s.substr(start, j); //一开始substr用法出错 if (isValid(tmp)) &#123; tmp += '.'; int len = out.size(); out += tmp; func(i + 1, part - 1, out, res, s); out = out.substr(0, len); &#125; &#125; &#125; bool isValid(string str) &#123; if (str.empty() || str.size() &gt; 3 || (str.size() &gt; 1 &amp;&amp; str[0] == '0')) return false; else &#123; int res = 0; for (int i = 0; i &lt; str.size(); i ++) &#123; res = res * 10 + str[i] - '0'; // 字符串转数字出错 &#125; return (res &lt;= 255 &amp;&amp; res &gt;=0); &#125; &#125;&#125;; 稍微快一档的做法，从6ms到3ms1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; if(s.size() &gt; 4 * 3 || s.size() &lt; 4) return &#123;&#125;; vector&lt;string&gt; res; func(0, 4, "", res, s); return res; &#125; void func(int start, int part, string out, vector&lt;string&gt;&amp; res, string s) &#123; if (start == s.size() &amp;&amp; part == 0) &#123; out.pop_back(); res.push_back(out); &#125; if (part &lt;= 0) return; //分出第五段的时候就返回 for (int i = start, j = 1; i &lt; s.size() &amp;&amp; j &lt;= 3; i++, j++) &#123; string tmp = s.substr(start, j); if (isValid(tmp)) func(i + 1, part - 1, out + tmp + '.', res, s); //减少了一些操作，让加减操作在赋值过程中完成 &#125; &#125; bool isValid(string str) &#123; if (str.empty() || str.size() &gt; 3 || (str.size() &gt; 1 &amp;&amp; str[0] == '0')) return false; else &#123; int res = 0; for (int i = 0; i &lt; str.size(); i ++) &#123; res = res * 10 + str[i] - '0'; &#125; return (res &lt;= 255 &amp;&amp; res &gt;=0); &#125; &#125;&#125;; LeetCode上大神的做法，还没看懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; int minLen = 4; int maxLen = 12; vector&lt;string&gt; result; if (s.size() &lt; minLen || s.size() &gt; maxLen) &#123; return result; &#125; restoreIpAddrHelper(s, "", result, 0); return result; &#125; private: void restoreIpAddrHelper(string s, string ans, vector&lt;string&gt; &amp;result, int octNum) &#123; if (s.size() == 0 &amp;&amp; octNum == 4) &#123; ans.pop_back(); result.push_back(ans); &#125; if ( (s.size() == 0 &amp;&amp; octNum != 4) || (s.size() &gt; 0 &amp;&amp; octNum == 4) )&#123; return; &#125; int count = (s.size() &gt; 3) ? 3 : s.size(); for (int i = 1; i &lt;= count; i++) &#123; string temp = s.substr(0, i); int number = atoi(temp.c_str()); if (number &gt; 255 || number &lt; 0) &#123; return; &#125; else if (temp.size() &gt; 1 &amp;&amp; temp[0] == '0') &#123; return; &#125; string ans_temp = ans; ans_temp.append(temp); ans_temp.append("."); restoreIpAddrHelper(s.substr(i, s.size()), ans_temp, result, octNum+1); &#125; &#125;&#125;; 79. Word SearchDescription:Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board =12345[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. 解题思路：貌似把题目理解错了，做不粗来~~~~(&gt;_&lt;)~~~~— 更新：题目没有理解错，但是有不少bug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int&gt;&gt; first; for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (board[i][j] == word[0]) first.push_back(&#123;j, i&#125;);//&#123;j, i&#125;应该为&#123;i, j&#125; &#125; &#125; if (first.empty()) return false; for (auto ch: first) &#123; bool flag = false; vector&lt;int&gt; used(n * m, 0); search(ch[0], ch[1], n, m, 0, word, flag, used, board); if (flag) return true; &#125; return false; &#125; //此处坐标反了，和递归函数的赋值不对应 void search(int pos_x, int pos_y, int n, int m, int k, string word, bool&amp; flag, vector&lt;int&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;//此处坐标反了，和递归函数的赋值不对应 if (k == word.size()) &#123;flag = true; return;&#125; char c = word[k]; //找了很久才发现的，board[pos_x][pos_y]，坐标反了，应该是board[pos_y][pos_x] if (pos_x &lt; m &amp;&amp; pos_y &lt; n &amp;&amp; pos_x &gt;= 0 &amp;&amp; pos_y &gt;= 0 &amp;&amp; board[pos_x][pos_y] == c) &#123; //up if (used[(pos_y - 1) * m + pos_x] == 0) &#123; used[(pos_y - 1) * m + pos_x] = 1; search(pos_y - 1, pos_x, n, m, k + 1, word, flag, used, board); used[(pos_y - 1) * m + pos_x] = 0; &#125; //down if (used[(pos_y + 1) * m + pos_x] == 0) &#123; used[(pos_y + 1) * m + pos_x] = 1; search(pos_y + 1, pos_x, n, m, k + 1, word, flag, used, board); used[(pos_y + 1) * m + pos_x] = 0; &#125; //left if (used[pos_y * m + (pos_x - 1)] == 0) &#123; used[pos_y * m + (pos_x - 1)] = 1; search(pos_y, pos_x - 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + (pos_x - 1)] = 0; &#125; //right if (used[pos_y * m + (pos_x + 1)] == 0) &#123; used[pos_y * m + (pos_x + 1)] = 1; search(pos_y, pos_x + 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + (pos_x + 1)] = 0; &#125; &#125; &#125;&#125;; 修改之后，能运行但超时的版本，后面的版本没有超时的原因是，通过与(||)操作的短路原理来实现剪枝，一旦发现一个true则不再执行后续的内容。1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); //vector&lt;vector&lt;int&gt;&gt; first; vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; bool flag = false; search(i, j, n, m, 0, word, flag, used, board); &#125; &#125; return false; &#125; void search(int pos_y, int pos_x, int n, int m, int k, string word, bool&amp; flag, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) &#123;flag = true; return;&#125; if (pos_x &lt; m &amp;&amp; pos_y &lt; n &amp;&amp; pos_x &gt;= 0 &amp;&amp; pos_y &gt;= 0 &amp;&amp; board[pos_y][pos_x] == word[k]) &#123; if (used[pos_y * m + pos_x] == true) return; used[pos_y * m + pos_x] = true; //up search(pos_y - 1, pos_x, n, m, k + 1, word, flag, used, board); //down search(pos_y + 1, pos_x, n, m, k + 1, word, flag, used, board); //left search(pos_y, pos_x - 1, n, m, k + 1, word, flag, used, board); //right search(pos_y, pos_x + 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + pos_x] = false; &#125; else return; &#125;&#125;; 加入与操作，不能通过版123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (search(i, j, n, m, 0, word, used, board)) return true; &#125; &#125; return false; &#125; bool search(int pos_y, int pos_x, int n, int m, int k, string word, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) return true; //问题就在board[pos_x][pos_y]坐标反了，半天没查出来 if (pos_x &gt;= m || pos_y &gt;= n || pos_x &lt; 0 || pos_y &lt; 0 || used[pos_y * m + pos_x] == true ||board[pos_x][pos_y] != word[k]) return false; used[pos_y * m + pos_x] = true; bool res = search(pos_y - 1, pos_x, n, m, k + 1, word, used, board) //up || search(pos_y + 1, pos_x, n, m, k + 1, word, used, board) //down || search(pos_y, pos_x - 1, n, m, k + 1, word, used, board) //left || search(pos_y, pos_x + 1, n, m, k + 1, word, used, board); //right used[pos_y * m + pos_x] = false; return res; &#125;&#125;; 调了半天后的AC版12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (search(i, j, 0, n, m, word, used, board)) return true; &#125; &#125; return false; &#125; bool search(int pos_y, int pos_x, int k, int n, int m,string word, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) return true; if (pos_x &gt;= m || pos_y &gt;= n || pos_x &lt; 0 || pos_y &lt; 0 || used[pos_y * m + pos_x] == true || board[pos_y][ pos_x] != word[k]) return false; used[pos_y * m + pos_x] = true; bool res = search(pos_y - 1, pos_x, k + 1, n, m, word, used, board) //up || search(pos_y + 1, pos_x, k + 1, n, m, word, used, board) //down || search(pos_y, pos_x - 1, k + 1, n, m, word, used, board) //left || search(pos_y, pos_x + 1, k + 1, n, m, word, used, board); //right used[pos_y * m + pos_x] = false; return res; &#125;&#125;; 211. Add and Search Word - Data structure designDescription Design a data structure that supports the following two operations:12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. For example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. Hint:You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.解题思路：不愧是boss关，不会做。建立字典树，然后通过字典树查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546class WordDictionary &#123;public: /** Initialize your data structure here. */ struct TrieNode &#123; public: TrieNode *child[26]; bool isWord; TrieNode() : isWord(false) &#123; for (auto &amp;a: child) &#123; a = NULL;&#125; &#125; &#125;; WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ void addWord(string word) &#123; TrieNode *p = root; for (auto &amp;a: word) &#123; int i = a - 'a'; if (!p -&gt; child[i]) p -&gt; child[i] = new TrieNode(); p = p -&gt; child[i]; &#125; p -&gt; isWord = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ bool search(string word) &#123; return searchWord(word, root, 0); &#125; bool searchWord(string&amp; word, TrieNode *p, int i) &#123; if (i == word.size()) return p -&gt; isWord; if (word[i] == '.') &#123; for (auto &amp;a: p -&gt; child) &#123; if (a &amp;&amp; searchWord(word, a, i + 1)) return true; &#125; return false; &#125; else &#123; return p -&gt; child[word[i] - 'a'] &amp;&amp; searchWord(word, p -&gt; child[word[i] - 'a'], i + 1); &#125; &#125; private: TrieNode *root;&#125;; Hard52. N-Queens IIDescription:Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 解题思路：深度优先方法，剔除掉对角线(其实是左上和右上)以及上方可能出现的棋子的情况进行递归和返回。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int totalNQueens(int n) &#123; vector&lt;bool&gt; used(n * n, false); return func(0, n, used); &#125; int func(int i, int n, vector&lt;bool&gt;&amp; used) &#123; int cnt = 0; if (i == n) return 1; for (int j = 0; j &lt; n; j ++) &#123; bool f = true; for (int ii = 0; ii &lt; i; ii ++) &#123; if (used[ii *n + j]) &#123; f = false; break; &#125; &#125; if (f == false) continue; //加上之后，略快一点儿 int min = i &lt; j ? i : j; for (int a = 1; a &lt;= min; a++) &#123; if (used[(i - a) * n + j - a]) &#123; f = false; break; &#125; &#125; if (f == false) continue; min = i &lt; (n - j - 1) ? i : (n - j - 1); for (int a = 1; a &lt;= min; a++) &#123; if (used[(i -a) * n + j + a]) &#123; f = false; break; &#125; &#125; if (f) &#123; used[i * n + j] = true; cnt += func(i + 1, n , used); used[i * n + j] = false; &#125; &#125; return cnt; &#125;&#125;; 51. N-QueensDescription:The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle:1234567891011[ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; table; for (int i = 0; i &lt; n; i++) &#123; string tmp = ""; for (int j = 0; j &lt; n; j ++) &#123; tmp += ((i ==j) ? 'Q' : '.'); &#125; table.push_back(tmp); &#125; vector&lt;string&gt; tmp; vector&lt;bool&gt; used(n * n, false); func(0, n, used, table, tmp, res); return res; &#125; void func(int i, int n, vector&lt;bool&gt;&amp; used, vector&lt;string&gt;&amp; table, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; int cnt = 0; if (i == n) res.push_back(tmp); for (int j = 0; j &lt; n; j ++) &#123; bool f = true; for (int ii = 0; ii &lt; i; ii ++) &#123; if (used[ii *n + j]) &#123; f = false; break; &#125; &#125; if (f == false) continue; int min = i &lt; j ? i : j; for (int a = 1; a &lt;= min; a++) &#123; if (used[(i - a) * n + j - a]) &#123; f = false; break; &#125; &#125; if (f == false) continue; min = i &lt; (n - j - 1) ? i : (n - j - 1); for (int a = 1; a &lt;= min; a++) &#123; if (used[(i -a) * n + j + a]) &#123; f = false; break; &#125; &#125; if (f) &#123; used[i * n + j] = true; tmp.push_back(table[j]); func(i + 1, n , used, table, tmp, res); tmp.pop_back(); used[i * n + j] = false; &#125; &#125; &#125; &#125;; OtherWorks Application笔试题 Coin GameDescription：There is a rectangular chessboard containing N*M cells, each of which either has one coin or nothing. You can move all the coins together in one direction (such as up, down, left, and right), but each time you can move these coins by only one cell. If any coins fall out of the chessboard, they must be thrown away. If it is required to keep K coins on the board, what is the minimum moves you have to take? Output -1 if you can not meet this requirement. 输入描述:The first line of the input are two positive integers n, representing the size of the board. For the next n line(s), each line has m numbers of characters, with ‘o’ indicating a coin, ‘.’ indicates an empty grid. The last line is a positive integer k, indicating the number of coins to be retained. 30% small input: 1 \le n,m \le 5, 0 \le k \le 2540% medium input: 1 \le n,m \le 10, 0 \le k \le 10030% large input: 1 \le n,m \le 100, 0 \le k \le 10000 输出描述:12Outputan integer that represents the number of moves, no solution output -1. 示例1输入123453 4.o..oooo..o.3 输出12 50% case通过率，复杂度过大，回溯如何剪枝？？？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int countFunc(int start_row, int end_row, int start_col, int end_col, vector&lt;vector&lt;char&gt;&gt; input) &#123; int cnt = 0; for (int i = start_row; i &lt; end_row; i++) &#123; for (int j = start_col; j &lt; end_col; j++) &#123; if (input[i][j] == 'o') cnt ++; &#125; &#125; return cnt;&#125;void func(int k, vector&lt;vector&lt;char&gt;&gt;&amp; input, int start_row, int end_row, int start_col, int end_col, int count, vector&lt;int&gt;&amp; res) &#123; int tmp_cnt = countFunc(start_row, end_row, start_col, end_col, input); if (tmp_cnt == k) &#123; res.push_back(count); return; &#125; else if (tmp_cnt &lt; k) return; // up if (start_row &lt; end_row) &#123; start_row += 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; start_row -= 1; &#125; // down if (start_row &lt; end_row) &#123; end_row -= 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; end_row += 1; &#125; // left if (start_col &lt; end_col) &#123; start_col += 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; start_col -= 1; &#125; // right if (start_col &lt; end_col) &#123; end_col -= 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; end_col += 1; &#125; &#125;int main() &#123; int n, m, k; char tmp; cin &gt;&gt; n; cin &gt;&gt; m; vector&lt;char&gt; temp; vector&lt;vector&lt;char&gt;&gt; input; int i = 1; while (cin &gt;&gt; tmp) &#123; temp.push_back(tmp); if (i % m == 0) &#123; input.push_back(temp); temp = &#123;&#125;; &#125; i++; if (i == m * n + 1) &#123; cin &gt;&gt; k; &#125; &#125; vector&lt;int&gt; res; int start_row = 0; int end_row = input.size(); int start_col = 0; int end_col = input.size(); func(k, input, start_row, end_row, start_col, end_col, 0, res); if (res.empty()) cout &lt;&lt; -1 &lt;&lt; endl; else &#123; sort(res.begin(), res.end()); cout &lt;&lt; res[0] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017秋招——京东]]></title>
      <url>%2F2017%2F09%2F16%2F2017%E7%A7%8B%E6%8B%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%9A%E4%BA%AC%E4%B8%9C%2F</url>
      <content type="text"><![CDATA[大量数据结构的问题 查找方式有哪些，都有哪些区别； 数组和链表的区别，分别是怎么实现的； 哈希表是如何实现的； 如何实现平衡树； 介绍一下红黑树；博客1，博客2 如何实现树的遍历； 汉诺塔问题 深度学习方面 过拟合、欠拟合； 过拟合有哪些解决方法； 欠拟合有哪些解决方法； GoogleNet； 怎么样去检测图像中的汽车； 深度学习有哪些超参数 哈希 构造合适的散列函数 除余法除数选用较大的素数，降低冲突发生的可能 MAD法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[降维之PCA主成分分析原理]]></title>
      <url>%2F2017%2F09%2F15%2F%E9%99%8D%E7%BB%B4%E4%B9%8BPCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[背景在许多领域的研究与应用中，往往需要对反映事物的多个变量进行大量的观测，收集大量数据以便进行分析寻找规律。多变量大样本无疑会为研究和应用提供了丰富的信息，但也在一定程度上增加了数据采集的工作量，更重要的是在多数情况下，许多变量之间可能存在相关性，从而增加了问题分析的复杂性，同时对分析带来不便。如果分别对每个指标进行分析，分析往往是孤立的，而不是综合的。盲目减少指标会损失很多信息，容易产生错误的结论。 因此需要找到一个合理的方法，在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量间存在一定的相关关系，因此有可能用较少的综合指标分别综合存在于各变量中的各类信息。主成分分析与因子分析就属于这类降维的方法。 目的PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。能够对高维数据降维的算法包括： LASSO 主成分分析法 聚类分析 小波分析法 线性判别法 拉普拉斯特征映射 作用降维有什么作用呢？ 数据在低维下更容易处理、更容易使用； 相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示； 去除数据噪声 降低算法开销 常见的降维算法有主成分分析（principal component analysis,PCA）、因子分析（Factor Analysis）和独立成分分析（Independent Component Analysis，ICA）。 优化目标将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差） 注意：PCA的变换矩阵是协方差矩阵，K-L变换的变换矩阵可以有很多种（二阶矩阵、协方差矩阵、总类内离散度矩阵等等）。当K-L变换矩阵为协方差矩阵时，等同于PCA。 原理最大化样本点在基上的投影，使得数据点尽量的分离。令第一主成分的方向是$u_1$，我们的目标就是将样本点在该方向上的投影最大化，即： \max {\frac{1}{n} \sum_{i=1}^n < u_1,x_i >^2} \frac{1}{n}\sum_{i=1}^n < u_1, x_i > \rightarrow \frac{1}{n}\sum_{i=1}^n(x_1^Tu_1)^2=\frac{1}{n}\sum_{i=1}^n(x_1^Tu_1)^T(x_1^Tu_1) =\frac{1}{n} \sum_{i=1}^n(u_1^T x_1 x_1^T u_1)= \frac{1}{n}u_1^T \left( \sum_{i=1}^n x_1 x_1^T \right) u_1 = \frac{1}{n} u_1^T \left(XX^T \right) u_1其中的$X=[x_1,x_2,…,x_n]^T,x_i\in R^{m}$。那么优化函数就变成了： \max u_1^T\left(XX^T\right)u_1以上式子是个二次型，可以证明XX^T是半正定矩阵，所以上式必然有最大值。 \max u_1^T\left(XX^T\right)u_1=\max ||X^Tu_1||_2^2优化函数 max||Wx||_2 s.t. W^TW=I解释：==最大化方差同时最小化协方差==（PCA本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”）。最大化方差意味着，使得每个样本点在每个维度上与均值有很大差异，就是说非常有个性，有个性才能分辨出来；同时协方差越小的话表明样本之间的互相影响就非常小，如果协方差是0的话，表示两个字段完全独立。 寻找协方差矩阵的特征向量和特征值就等价于拟合一条能保留最大方差的直线或主成分。因为特征向量追踪到了主成分的方向，而最大方差和协方差的轴线表明了数据最容易改变的方向。根据上述推导，我们发现达到优化目标就等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将特征值按大小从上到下排列。协方差矩阵作为实对称矩阵，其主要性质之一就是可以正交对角化，因此就一定可以分解为特征向量和特征值。 步骤总结一下PCA的算法步骤： 设有$m$条$n$维(字段数)数据。 将原始数据按列组成$n$行$m$列矩阵X. (行数代表字段数目，一个字段就是取每个样本的该维度的数值；列数代表样本数目) 将$X$的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值 求出协方差矩阵$C=\frac{1}{m}XX^T$ 求出协方差矩阵的特征值及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P $Y=PX$即为降维到k维后的数据 去均值化的目的下面两幅图是数据做中心化（centering）前后的对比，可以看到其实就是一个平移的过程，平移后所有数据的中心是(0,0). 在做PCA的时候，我们需要找出矩阵的特征向量，也就是主成分（PC）。比如说找到的第一个特征向量是a = [1, 2]，a在坐标平面上就是从原点出发到点（1，2）的一个向量。如果没有对数据做中心化，那算出来的第一主成分的方向可能就不是一个可以“描述”（或者说“概括”）数据的方向了。还是看图比较清楚。 黑色线就是第一主成分的方向。只有中心化数据之后，计算得到的方向才能比较好的“概括”原来的数据。 限制PCA虽可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel PCA，通过Kernel函数将非线性相关转为线性相关 参考 PCA的数学原理 K-L变换和PCA的区别 从PCA和SVD的关系拾遗 数据什么时候需要做中心化和标准化处理 主成分分析（PCA）原理详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo使用指南]]></title>
      <url>%2F2017%2F09%2F14%2FHexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: DeploymentMore Tips:数学符号Latex math symbol 主题个性化hexo流程图hexo-filter-flowchart Hexo之NexT主题搭建博客详细过程 Hexo docst=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>%2F2017%2F09%2F13%2F%E5%BF%AB%E6%8E%92%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[博客上的代码1 博客上的代码2 1234567891011121314151617void quickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; int i = left; int j = right; int temp = array[left]; while (i != j) &#123; while (i &lt;j &amp;&amp; temp &lt;= array[j]) j --; if (i &lt; j) array[i] = array[j]; while (i &lt; j &amp;&amp; temp &gt; array[i]) i ++; if (i &lt; j) array[j] = array[i]; &#125; array[i] = temp; quickSort(array, left, i - 1); quickSort(array, i + 1, right);&#125; 分治思想 1234567891011121314151617181920212223int partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int i = left; int j = right; int temp = array[left]; while (i != j) &#123; while (i &lt;j &amp;&amp; temp &lt;= array[j]) j --; if (i &lt; j) array[i] = array[j]; while (i &lt; j &amp;&amp; temp &gt; array[i]) i ++; if (i &lt; j) array[j] = array[i]; &#125; array[i] = temp; return i;&#125;void quickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int dp = partition(array, left, right); quickSort(array, left, dp - 1); quickSort(array, dp + 1, right); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优化算法]]></title>
      <url>%2F2017%2F08%2F13%2F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[优化算法对目标函数求梯度 $\nabla_{\theta} J(\theta)$ 批量梯度下降利用所有训练数据，计算目标函数梯度，$\eta$是学习率(learning rate) \theta = \theta - \eta \cdot \nabla_{\theta} J(\theta)缺点：一次参数更新需要计算整体数据的梯度，内存消耗大，不支持模型在线更新 随机梯度下降训练中，利用一个样本$x^{(i)}$ 和标签 $y^{(i)}$进行一次参数更新 \theta = \theta - \eta \cdot \nabla J(\theta;x^{(i)};y^{(i)})优点： 速度快，支持在线学习 缺点： 高方差，目标函数值剧烈波动 随机波动，容易陷入局部极小值 mini-batch 随机下降结合前两种，在训练中，利用一个 batch 样本$x^{(i)}$ 和标签 $y^{(i)}$进行一次参数更新 \theta = \theta - \eta \cdot \nabla J(\theta;x^{(i:i+n)};y^{(i:i+n)})优点： 减小参数更新的方程，收敛更平稳 可以根据内存来控制输入 Momentum帮助SGD在相关方向上加速并抑制震荡，当前向量 v_{t} 的更新考虑了上一个时刻向量 v_{t-1} 的作用 \left\{ \begin{aligned} v_t & = &\underbrace{\gamma v_{t-1}}_{momenturm \,term} &+& \eta \cdot \nabla_{\theta} J(\theta)\\ \theta & = &\theta &-& v_t \\ \end{aligned} \right.Nesterov accelerated gradient(NAG)给momentum term引入先验 \left\{ \begin{aligned} v_t & = \gamma v_{t-1} + \eta \cdot \nabla_{\theta} J(\theta - \gamma v_{t-1})\\ \theta & = \theta - v_t \\ \end{aligned} \right.AdaGrad之前的方法对所有参数$\theta$都用了相同的学习率$\eta$，AdaGrad在时刻$t$对每个参数$\theta_i$采用了不同的学习速率$\eta$$\theta_i$在$t$时刻的梯度： g_{t,i} = \nabla_\theta J(\theta_i)SGD对在$t$时刻的参数$\theta_i$更新， \theta_{t+1, i} = \theta_{t,i} - \eta \cdot g_{t,i}AdaGrad在$t$时刻的参数$\theta_i$更新， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{G_{t,i} + \epsilon}} \cdot g_{t,i}其中，$G_{t} \in \mathbb{R}^{d \times d}$是一个对角矩阵，对角元素$i$是每个参数$\theta_i$到t时刻为止，所有时刻梯度的平方之和，$\epsilon$为避免分母为0。进一步，写成element-wise matrix-vector multiplication形式， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{G_{t} + \epsilon}} \odot g_{t}优点 不用人工调整学习率，默认0.01 缺点 在分母中累积梯度的平方，在训练过程中导致学习率一直在减小 需要手动设置一个全局初始学习率 更新$\theta_t$时，左右两边的单位不一致 Adadelta为缓解AdaGrad学习率单调递减问题做出的扩展。不对过去所以时刻梯度平方累积，将累积时刻限制在窗口大小为$w$的区间递归使得定义为过去所有时刻梯度平方的decaying average(?)。时刻$t$的running average $E[g^2]_t$仅仅依赖于之前average和当前的梯度$\gamma$是一个衰减系数，随着时间指数衰减，因此与当前时刻比较近的$g_t$对梯度计算更起作用 E[g^2]_t = \gamma E[g^2]_{t-1} + (1-\gamma)g^2_t将对角矩阵$G_t$替换为过去$t$时刻梯度平方的dacaying average $E[g^2]_t$ \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{E[g^2]_t + \epsilon}} \odot g_{t}RMSprop和Adadelta原理相似？？？ AdamAdaptvie Moment Estimation (Adam) 自适应学习速率计算方法。保存过去梯度平方和+momentum。 m_t=\beta_1 m_{t-1} + (1 - \beta_1) g_t\\ v_t = \beta_2 v_{t - 1} + (1 - \beta_2) g_t^2其中，$m_t$和$v_t$分别是梯度的一阶矩（均值）和二阶矩（偏方差）的估计为消除估计值的偏差，计算bias-corrected \widehat{m}_t = \frac{m_t}{1-\beta^t_1}\\ \widehat{v}_t = \frac{v_t}{1 - \beta^t_2}更新规则， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{\widehat{v}_t + \epsilon}} \widehat{m}_t默认设置，$\beta_1 = 0.9,\beta_2=0.999,\epsilon=10^{-8}$ 【各优化算法对比-投影面】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习修炼手册]]></title>
      <url>%2F2017%2F05%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[对机器学习的学习我开始于二年级的《数据挖掘》课，当时袁老师对数据挖掘中的常用的算法做了一些介绍，但是这仅仅是个入门教学，我并没有深入了解的其中的原理。到现在我才深刻的意识到ML的重要性，我就抽空看了一些这方面的资料，整理了这一份文档。 机器学习算法包括，监督学习(回归、分类)以及非监督学习(聚类)。 梯度下降\bbox[5px,border:2px solid red] { \theta_j:=\theta_j-\alpha\frac{\partial}{\partial \theta}J(\theta) }其中$\alpha$为学习率一般为很小的数字(0.001-0.1)，$\theta$为我们需要求解的参数，$J(\theta)$为能量函数或者为损失函数，通过上述公式可知，梯度下降是沿着损失函数梯度的反方向寻找迭代寻找最优值的过程。梯度下降容易陷入局部最极小点，所以我们要采取一定的措施来阻止这种现象的发生。 过拟合（Overfitting）如果训练样本的特征过多，我们学习的假设可能在训练集上表现地很好，但是在验证集上表现地就不尽人意 避免过拟合 减少特征的大小 正则化 在保证所有特征都保留的情况下，限制$\theta$的大小，即Small values for parameters $ \theta_0,\theta_1,\theta_2…\theta_n$ 当特征量很多时，该方式仍然表现的很好 交叉验证(Cross Validation) 正则化线性回归对于线性回归而言，其损失函数形式如下： J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2引入正则化之后的损失函数的形式为： J(\theta)=\frac{1}{2m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}\theta_{j}^2\right)GD迭代求解参数Repeat{ \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)x_0^{(i)} \theta_j:=\theta_j-\alpha\frac{1}{m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda\theta_j\right)}梯度下降法的学习率$\alpha$需要提前指定，并且还要制定收敛标准。 Normal Equation \theta=\left(x^Tx+\lambda\begin{bmatrix} {0}&{0}&{\cdots}&{0}\\ {0}&{1}&{\cdots}&{0}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{1}\\ \end{bmatrix}_{(n+1)(n+1)}\right)^{-1}x^Ty上式是对线性回归正则化后的矩阵解。可以证明的是当$\lambda&gt;0$时，求逆符号内部的式子总是可逆的。 逻辑回归在没有加入正则化之前，逻辑回归的损失函数的形式是这样的： J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}\left(y^{(i)}\log\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})\log\left(1-h_{\theta}(x^{(i)})\right)\right)加入正则项之后的形式为： J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}\left(y^{(i)}\log\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})\log\left(1-h_{\theta}(x^{(i)})\right)\right)+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2GD迭代求解参数Repeat{ \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)x_0^{(i)}\theta_j:=\theta_j-\alpha\frac{1}{m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda\theta_j\right)} SVM支持向量机支持向量机又被称作最大间距（Large Margin）分类器，损失函数的形式是： J(\theta)=C\sum_{i=1}^{m}\left(y^{(i)}cost_1\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})cost_0\left(h_{\theta}(x^{(i)})\right)\right)+\frac{1}{2}\sum_{j=1}^{n}\theta_j^2其中：$h_{\theta}(x^{(i)})=\theta^Tx^{i}$，$cost_1$以及$cost_0$的形式如下图所示： \begin{cases} \text{we want } \theta^Tx\ge1, & \text{if $y$ =1} \\[2ex] \text{we want } \theta^Tx\le-1, & \text{if $y$ =0} \end{cases}]]></content>
    </entry>

    
  
  
</search>
