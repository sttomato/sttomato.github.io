<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[LeetCode Backtracking]]></title>
      <url>%2F2017%2F09%2F21%2FLeetCode-Backtracking%2F</url>
      <content type="text"><![CDATA[MediumProblems Lists What is Backtracking? 357. Count Numbers with Unique DigitsDescriptionGiven a non-negative integer n, count all numbers with unique digits, x, where $0 \le x &lt; 10^n$. Example:Given n = 2, return 91. (The answer should be the total numbers in the range of $0 \le x &lt; 100$, excluding [11,22,33,44,55,66,77,88,99]) Credits:Special thanks to @memoryless for adding this problem and creating all test cases. 解题思路：一个n位数并且每位数字不重复，总共有这么多个数字 f(n) = {A_{10}^n} - {A_{9}}^{n-1}设 f(0) = A_{10}^0 = 1然后累加。 1234567891011121314151617181920212223class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; if (n &lt; 0) return 0; if (n &gt; 10) n = 10; int result = 0; int tmp1 = 1; int tmp2 = 0; for (int i = 0; i &lt;= n; i++) &#123; result += tmp1 - tmp2; tmp1 *= 10 - i; if (i == 0) &#123; tmp2 = 1; &#125; else &#123; tmp2 *= 10 - i; &#125; &#125; return result; &#125;&#125;; 回溯方法 1234567891011121314151617181920212223242526class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; int res = 1, max = pow(10, n), used = 0; for (int i = 1; i &lt; 10; ++i) &#123; used |= (1 &lt;&lt; i); res += search(i, max, used); used &amp;= ~(1 &lt;&lt; i); &#125; return res; &#125; int search(int pre, int max, int used) &#123; int res = 0; if (pre &lt; max) ++res; else return res; for (int i = 0; i &lt; 10; ++i) &#123; if (!(used &amp; (1 &lt;&lt; i))) &#123; used |= (1 &lt;&lt; i); int cur = 10 * pre + i; res += search(cur, max, used); used &amp;= ~(1 &lt;&lt; i); &#125; &#125; return res; &#125;&#125;; bug版回溯123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; if (n &gt; 10) &#123; return countNumbersWithUniqueDigits(10); &#125; vector&lt;bool&gt; used(10, false); int count = 1; long max = pow(10, n); for (int i = 0; i &lt; 10; i++) &#123; used[i] = true; count += search(i, max, used); used[i] = false; &#125; return count; &#125; int search(long pre, long max, vector&lt;bool&gt;&amp; used) &#123; int count = 0; if (pre &lt; max) count++; else return count; for (int i = 0; i &lt; 10; i++) &#123; if (!used[i]) &#123; used[i] = true; long cur = 10 * pre + i; count += search(cur, max, used); used[i] = false; &#125; &#125; return count; &#125;&#125;; 22. Generate ParenthesesDescriptionGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 解题思路：合法字符串的任意位置，右括号数量不大于左括号数量。12345678910111213141516class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; func(n, n, "", res); return res; &#125; void func(int left, int right, string tmp, vector&lt;string&gt; &amp;res) &#123; if (left &gt; right) return; if (left ==0 &amp;&amp; right == 0) res.push_back(tmp); if (left &gt; 0) func(left - 1, right, tmp + '(', res); if (right &gt; 0) func(left, right - 1, tmp + ')', res); &#125;&#125;; 参考来源 216. Combination Sum IIIDescription： Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1: Input: k = 3, n = 7 Output:1[[1,2,4]] Example 2: Input: k = 3, n = 9 Output:1[[1,2,6], [1,3,5], [2,3,4]] Credits:Special thanks to @mithmatt for adding this problem and creating all test cases. 解题思路：把已经算过的数放入一个向量中，在不满足条件的情况下，把值退出来；满足条件下，把最终结果保存 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(k, n, 1, tmp, res); return res; &#125; void func(int k, int n, int level, vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (n &lt; 0) return; if (n == 0 &amp;&amp; tmp.size() == k) res.push_back(tmp); for (int i = level; i &lt;= 9; i++) &#123; tmp.push_back(i); func(k, n - i, i + 1, tmp, res); //func(k, n - i, level + 1, tmp, res);//bug版本；也能输出，但是会出现重复数字 tmp.pop_back(); &#125; &#125;&#125;; 参考 46. PermutationsDescription： Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] ！！！这是宝宝写出来的第一个回溯算法题！！！解题思路：大循环【从nums中擦除一个数，在tmp中加入，然后把nums和tmp放到下一层递归；终止条件是当nums==0，tmp的大小和最初nums一样大时，查找tmp是否在结果中，如果在跳出，否则加入结果；然后把擦除的数插入回nums，tmp弹出这个数】123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(nums, tmp, res); return res; &#125; void func(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if (nums.size() == 0 &amp;&amp; find(res.begin(), res.end(), tmp) != res.end()) return; if (nums.size() == 0 &amp;&amp; find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); for (auto iter = nums.begin(); iter != nums.end(); iter++) &#123; int val = *iter; tmp.push_back(val); nums.erase(iter); func(nums, tmp, res); nums.insert(iter, val); tmp.pop_back(); &#125; &#125;&#125;; 别人的解 89. Gray CodeDescription: The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:123400 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 公式法：每个格雷码 = 当前二进制数 异或 （当前二进制数右移一位） 12345678910class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; pow(2, n); i++) &#123; res.push_back((i &gt;&gt; 1) ^ i); &#125; return res; &#125;&#125;; 镜像翻转法： 12345678910111213class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; res.push_back(0); for (int i = 0; i &lt; n; i++) &#123; for (int j = pow(2, i) - 1; j &gt;= 0; j--) &#123; res.push_back(res[j] | (1 &lt;&lt; i)); &#125; &#125; return res; &#125;&#125;; 回溯法，目前没搞明白……囧 回溯法1 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; unordered_set&lt;int&gt; s; helper(n, s, 0, res); return res; &#125; void helper(int n, unordered_set&lt;int&gt;&amp; s, int out, vector&lt;int&gt;&amp; res) &#123; if (!s.count(out)) &#123; s.insert(out); res.push_back(out); &#125; for (int i = 0; i &lt; n; ++i) &#123; int t = out; if ((t &amp; (1 &lt;&lt; i)) == 0) t |= (1 &lt;&lt; i); else t &amp;= ~(1 &lt;&lt; i); if (s.count(t)) continue; helper(n, s, t, res); break; &#125; &#125;&#125;; 回溯法21234567891011121314151617181920212223242526272829303132333435int conversion(int n)&#123; int temp=1; if(n==1) return 1; for(int i=1;i&lt;n;i++) temp=temp*2; return temp;&#125;vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result; if(n==0) &#123; result.push_back(0); return result; &#125; if(n==1) &#123; result.push_back(0); result.push_back(1); return result; &#125; else &#123; //queue&lt;int&gt; temp; result=grayCode(n-1); int len=result.size(); for(int i=len-1;i&gt;=0;--i) &#123; int temp=result[i]+conversion(n); result.push_back(temp); &#125; return result; &#125;&#125; 78. SubsetsDescription： Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路：12345678910 [] / \ / \ / \ [1] [] / \ / \ / \ / \ [1 2] [1] [2] [] / \ / \ / \ / \[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] [] 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp = &#123;&#125;; func(0, tmp, res, nums); return res; &#125; void func(int pos, vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;nums) &#123; res.push_back(tmp); for (int i = pos; i &lt; nums.size(); i ++) &#123; tmp.push_back(nums[i]); func(i + 1, tmp, res, nums); tmp.pop_back(); &#125; &#125;&#125;; 77. CombinationsDescription:Given two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is:12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路：这题是组合情况，比之前的46题排列情况更简单一点 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; input; vector&lt;int&gt; tmp; for (int i = 1; i &lt;= n; i++) &#123; input.push_back(i); &#125; func(n, k, tmp, 0, res); return res; &#125; void func(int n, int k, vector&lt;int&gt; &amp;tmp, int pos, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (tmp.size() == k &amp;&amp; find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else if (tmp.size() == k) return; for (int i = pos; i &lt; n; i++) &#123; tmp.push_back(i + 1); func(n, k, tmp, i + 1, res); tmp.pop_back(); &#125; &#125;&#125;; 39. Combination SumDescription: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:1234[ [7], [2, 2, 3]] 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //int sum = 0; func(target, tmp, res, candidates); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates) &#123; int sum = 0; for (auto c: tmp) sum += c; if (sum &gt; target) return; else if (sum == target) &#123; vector&lt;int&gt; tmp2 =tmp; //一开始没有加tmp2变量，导致每次排序之后tmp.pop_back()改变原先内容 sort(tmp2.begin(), tmp2.end()); if (find(res.begin(), res.end(), tmp2) == res.end()) res.push_back(tmp2); else return; &#125; for (int i = 0; i &lt; candidates.size(); i++) &#123; tmp.push_back(candidates[i]); func(target, tmp, res, candidates); tmp.pop_back(); &#125; &#125;&#125;; faster123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //int sum = 0; func(target, tmp, res, candidates); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates) &#123; if (0 == target) &#123; vector&lt;int&gt; tmp2 =tmp; sort(tmp2.begin(), tmp2.end()); if (find(res.begin(), res.end(), tmp2) == res.end()) res.push_back(tmp2); else return; &#125; for (int i = 0; i &lt; candidates.size(); i++) &#123; if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(target - candidates[i], tmp, res, candidates); tmp.pop_back(); &#125; &#125; &#125;&#125;; more faster12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //sort(candidates.begin(), candidates.end()); func(target, tmp, res, candidates, 0); return res; &#125; void func(int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; candidates, int idx) &#123; if (0 == target) &#123; res.push_back(tmp); return; &#125; for (int i = idx; i &lt; candidates.size(); i++) &#123; //if(i&gt;idx &amp;&amp; candidates[i]==candidates[i-1]) continue; if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(target - candidates[i], tmp, res, candidates, i); tmp.pop_back(); &#125; &#125; &#125;&#125;; 90. Subsets IIDescription: Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is:12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路：此题与Subsets非常思路相同，只是在加入过程中多用了一个查找来判断重复，12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp = &#123;&#125;; sort(nums.begin(), nums.end()); int size = nums.size(); func(0, tmp, res, nums); return res; &#125; void func(int idx, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums) &#123; if (find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else return; for (int i = idx; i &lt;nums.size(); i++) &#123; tmp.push_back(nums[i]); func(i + 1, tmp, res, nums); tmp.pop_back(); &#125; &#125;&#125;; 17. Letter Combinations of a Phone NumberDescription： Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below.12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 解题思路：把这个问题构造成一个普通的回溯问题，差别在于一般回溯问题都是在一个向量上操作的，这个是在二维向量上操作，难点在于把二维向量构造出来，然后就可以了，不会存在重复和排序问题。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;char&gt;&gt; makeTable() &#123; //如果不看这个函数，代码还是挺简洁的 (=´ω｀=) vector&lt;vector&lt;char&gt;&gt; m; vector&lt;char&gt; tmp0 = &#123;'a', 'b', 'c'&#125;; m.push_back(tmp0); vector&lt;char&gt; tmp1 = &#123;'d', 'e', 'f'&#125;; m.push_back(tmp1); vector&lt;char&gt; tmp2 = &#123;'g', 'h', 'i'&#125;; m.push_back(tmp2); vector&lt;char&gt; tmp3 = &#123;'j', 'k', 'l'&#125;; m.push_back(tmp3); vector&lt;char&gt; tmp4 = &#123;'m', 'n', 'o'&#125;; m.push_back(tmp4); vector&lt;char&gt; tmp5 = &#123;'p', 'q', 'r', 's'&#125;; m.push_back(tmp5); vector&lt;char&gt; tmp6 = &#123;'t', 'u', 'v'&#125;; m.push_back(tmp6); vector&lt;char&gt; tmp7 = &#123;'w', 'x', 'y', 'z'&#125;; m.push_back(tmp7); return m; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return &#123;&#125;; vector&lt;vector&lt;char&gt;&gt; m = makeTable(); vector&lt;string&gt; res; string tmp = ""; func(tmp, 0, digits, m, res); return res; &#125; void func(string tmp, int idx, string digits, vector&lt;vector&lt;char&gt;&gt;&amp; m, vector&lt;string&gt;&amp; res) &#123; if (idx == digits.size()) res.push_back(tmp); int digits_i = digits[idx] - '2'; for (int i = 0; i &lt; m[digits_i].size(); i++) &#123; tmp += m[digits_i][i]; func(tmp, idx + 1, digits, m, res); tmp.pop_back(); &#125; &#125;&#125;; 40. Combination Sum IIDescription: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is:123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解题思路：这题是在Combination Sum基础上加了两个变化，一个是无序，另一个是重复数字，对应的策略也就是在Combination Sum中被我注释的两行(一开始是抄了人家的代码，没抄明白，发现注释了也能跑通，现在才大致知道作用是什么了) 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); func(0, target, tmp, candidates, res); return res; &#125; void func(int idx, int target, vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; //if (target &lt; 0) return; if (target == 0) res.push_back(tmp); for(int i = idx; i &lt; candidates.size(); i++) &#123; if (i &gt; idx &amp;&amp; candidates[i] == candidates[i - 1]) continue; //这句的作用在于，一个是让在这一层中，相同的数字不再继续往下找；第二，i &gt; idx 而不是 i &gt; 0是确保了从idx开始的数能够被保存进来 if (target &gt;= candidates[i]) &#123; tmp.push_back(candidates[i]); func(i + 1, target - candidates[i], tmp, candidates, res); tmp.pop_back(); &#125; else return; //这句让效率从24%到85%，之所以能用，是因为candidates数组已经排序过，数组后面的数必然都不满足 &#125; &#125;&#125;; 131. Palindrome PartitioningDescription： Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = &quot;aab&quot;,Return1234[ ["aa","b"], ["a","a","b"]] 解题思路：思路很混乱， 第一，先有一个判断回文的函数；然后从前往后逐一取子集，如果当前字符是回文的则保存，并把后续的子字符串当做新字符串，依次迭代。有个难点是，边界问题。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool ispalindrome(string str) &#123; for (int i = 0, j = str.size() - 1; i &lt; j; i ++, j--) &#123; if (str[i] != str[j]) return false; &#125; return true; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; out; // string tmp; func("", s, out, res); return res; &#125; void func(string tmp, string str, vector&lt;string&gt;&amp; out, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (str.size() == 1) &#123; out.push_back(str); res.push_back(out); out.pop_back(); return; &#125; for (int i = 0; i &lt; str.size(); i++) &#123; tmp += str[i]; if (ispalindrome(tmp)) &#123; out.push_back(tmp); if (i == str.size() - 1) res.push_back(out); else func("", str.substr(i + 1, str.size() - i - 1), out, res); out.pop_back(); &#125; &#125; &#125;&#125;; 3ms大神的解法(我的是9ms)，代码非常简洁易懂，就是学不来。跟我的区别最大的是，他保存的是子串，往下传递的是坐标，方法上比较接近于普通的回溯。12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; ret; vector&lt;string&gt; tmp; DFS(ret, tmp, s, 0); return ret; &#125; private: void DFS(vector&lt;vector&lt;string&gt;&gt;&amp; ret, vector&lt;string&gt;&amp; tmp, string&amp; s, int pos) &#123; if (pos == s.size()) &#123; ret.push_back(tmp); return; &#125; for (int i = pos; i &lt; s.size(); ++i) &#123; if(test(s, pos, i)) &#123; tmp.push_back(s.substr(pos, i-pos+1)); DFS(ret, tmp, s, i+1); tmp.pop_back(); &#125; &#125; &#125; bool test(string&amp; str, int start, int end) //检查函数 &#123; while (start &lt; end &amp;&amp; str[start] == str[end]) &#123; ++start; --end; &#125; return (start &gt;= end); &#125;&#125;; 47. Permutations IIDescription： Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations:12345[ [1,1,2], [1,2,1], [2,1,1]] 解题思路：这题在没有1,2两句的情况下，一直受到时间限制的困扰，加上之后就能通过。12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; //vector&lt;int&gt; used(nums.size(), 0); int size = nums.size(); sort(nums.begin(), nums.end()); //1 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; func(tmp, res, size, nums); return res; &#125; void func(vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res, int size, vector&lt;int&gt;&amp; nums) &#123; if (tmp.size() == size) &#123; if (find(res.begin(), res.end(), tmp) == res.end()) res.push_back(tmp); else return; &#125; for (auto iter = nums.begin(); iter != nums.end(); iter++) &#123; //if (used[i] == 0) &#123; //used[i] = 1; if (iter &gt; nums.begin() &amp;&amp; *iter == *(iter - 1)) continue; //2 在排序之后相等的数字连续出现，重复数字不再进入下层递归，减小了时间复杂度。 int val = *iter; tmp.push_back(val); nums.erase(iter); func(tmp, res, size, nums); nums.insert(iter, val); tmp.pop_back(); //used[i] = 0; //&#125; &#125; &#125;&#125;; 目前LeetCode上最快的解，学习无能Orz12345678910111213141516171819202122232425262728class Solution &#123;public: void myPermute(vector&lt;int&gt; nums, int start, vector&lt;vector &lt;int&gt;&gt;&amp; result) &#123; int length = nums.size(); if (start == length) &#123; result.push_back(nums); // cout &lt;&lt; per[1] &lt;&lt; per[2] &lt;&lt; per[3] &lt;&lt; endl; return; &#125; for (int i = start; i &lt; length; i++) &#123; if (i != start &amp;&amp; nums[i] == nums[start]) continue; swap(nums[i], nums[start]); myPermute(nums, start + 1, result); // swap(nums[i], nums[start]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int length = nums.size(); vector&lt;vector &lt;int&gt;&gt; result; myPermute(nums, 0, result); return result; &#125;&#125;; 60. Permutation SequenceDescription： The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3):123456"123""132""213""231""312""321" Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 解题思路：如果用Permutations的思路来做的话，会超时。可以发现排序的数字仅看第一位，总是按照1, 2 , 3 ,..., n，这样的顺序排列的，然后看第一位之后的排序方式有A_{n-1}^{n-1}，也就是以1打头的数字排在[0,\ A_{n-1}^{n-1}]之间，以2打头的数字排在[A_{n-1}^{n-1} + 1,\ 2 \times A_{n-1}^{n-1}]，以x打头的数字排在[(x - 1) \times A_{n-1}^{n-1} + 1,\ x \times A_{n-1}^{n-1}]之间。确定第一个数字之后，后面的序列排在第k = k - (x - 1) \times A_{n-1}^{n-1}个，往下依次类推。1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string getPermutation(int n, int k) &#123; string res = ""; vector&lt;int&gt; nums; for (int i = 1; i &lt;= n; i++) nums.push_back(i); int a = cntFunc(n - 1); func(res, k, n, a, nums); return res; &#125; int cntFunc(int n) &#123; if (n &lt;= 0) return 1; int res = 1; for (int i = 1; i &lt;= n; i ++) res *= i; return res; &#125; void func(string&amp; res, int k, int n, int a, vector&lt;int&gt;&amp; nums) &#123; if (n == 0) return; //int a = cntFunc(n - 1); int i = 0; for (auto iter = nums.begin(); iter != nums.end(); iter ++, i++) &#123; if ((i * a &lt; k) &amp;&amp; ((i + 1) * a &gt;= k)) &#123; //通过条件来剪枝，否则会超时 int val = *iter; res += val + '0'; if (n &gt; 1) &#123; nums.erase(iter); //这种操作在VS2015上会报错 func(res, k - (i * a), n - 1, a / (n - 1), nums); nums.insert(iter, val); &#125; else break; &#125; &#125; &#125;&#125;; 93. Restore IP AddressesDescription: Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example:Given &quot;25525511135&quot;, return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) 解题思路：用一个函数判断字符串是否合法，然后就是回溯 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; if(s.size() &gt; 4 * 3 || s.size() &lt; 4) return &#123;&#125;; //减少无效字符输入 vector&lt;string&gt; res; func(0, 4, "", res, s); return res; &#125; void func(int start, int part, string out, vector&lt;string&gt;&amp; res, string s) &#123; if (start == s.size() &amp;&amp; part == 0) &#123; out.pop_back(); res.push_back(out); &#125; for (int i = start, j = 1; i &lt; s.size(); i++, j++) &#123; if (j &gt; 3) return; string tmp = s.substr(start, j); //一开始substr用法出错 if (isValid(tmp)) &#123; tmp += '.'; int len = out.size(); out += tmp; func(i + 1, part - 1, out, res, s); out = out.substr(0, len); &#125; &#125; &#125; bool isValid(string str) &#123; if (str.empty() || str.size() &gt; 3 || (str.size() &gt; 1 &amp;&amp; str[0] == '0')) return false; else &#123; int res = 0; for (int i = 0; i &lt; str.size(); i ++) &#123; res = res * 10 + str[i] - '0'; // 字符串转数字出错 &#125; return (res &lt;= 255 &amp;&amp; res &gt;=0); &#125; &#125;&#125;; 稍微快一档的做法，从6ms到3ms1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; if(s.size() &gt; 4 * 3 || s.size() &lt; 4) return &#123;&#125;; vector&lt;string&gt; res; func(0, 4, "", res, s); return res; &#125; void func(int start, int part, string out, vector&lt;string&gt;&amp; res, string s) &#123; if (start == s.size() &amp;&amp; part == 0) &#123; out.pop_back(); res.push_back(out); &#125; if (part &lt;= 0) return; //分出第五段的时候就返回 for (int i = start, j = 1; i &lt; s.size() &amp;&amp; j &lt;= 3; i++, j++) &#123; string tmp = s.substr(start, j); if (isValid(tmp)) func(i + 1, part - 1, out + tmp + '.', res, s); //减少了一些操作，让加减操作在赋值过程中完成 &#125; &#125; bool isValid(string str) &#123; if (str.empty() || str.size() &gt; 3 || (str.size() &gt; 1 &amp;&amp; str[0] == '0')) return false; else &#123; int res = 0; for (int i = 0; i &lt; str.size(); i ++) &#123; res = res * 10 + str[i] - '0'; &#125; return (res &lt;= 255 &amp;&amp; res &gt;=0); &#125; &#125;&#125;; LeetCode上大神的做法，还没看懂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; int minLen = 4; int maxLen = 12; vector&lt;string&gt; result; if (s.size() &lt; minLen || s.size() &gt; maxLen) &#123; return result; &#125; restoreIpAddrHelper(s, "", result, 0); return result; &#125; private: void restoreIpAddrHelper(string s, string ans, vector&lt;string&gt; &amp;result, int octNum) &#123; if (s.size() == 0 &amp;&amp; octNum == 4) &#123; ans.pop_back(); result.push_back(ans); &#125; if ( (s.size() == 0 &amp;&amp; octNum != 4) || (s.size() &gt; 0 &amp;&amp; octNum == 4) )&#123; return; &#125; int count = (s.size() &gt; 3) ? 3 : s.size(); for (int i = 1; i &lt;= count; i++) &#123; string temp = s.substr(0, i); int number = atoi(temp.c_str()); if (number &gt; 255 || number &lt; 0) &#123; return; &#125; else if (temp.size() &gt; 1 &amp;&amp; temp[0] == '0') &#123; return; &#125; string ans_temp = ans; ans_temp.append(temp); ans_temp.append("."); restoreIpAddrHelper(s.substr(i, s.size()), ans_temp, result, octNum+1); &#125; &#125;&#125;; 79. Word SearchDescription:Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board =12345[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. 解题思路：貌似把题目理解错了，做不粗来~~~~(&gt;_&lt;)~~~~— 更新：题目没有理解错，但是有不少bug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;vector&lt;int&gt;&gt; first; for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (board[i][j] == word[0]) first.push_back(&#123;j, i&#125;);//&#123;j, i&#125;应该为&#123;i, j&#125; &#125; &#125; if (first.empty()) return false; for (auto ch: first) &#123; bool flag = false; vector&lt;int&gt; used(n * m, 0); search(ch[0], ch[1], n, m, 0, word, flag, used, board); if (flag) return true; &#125; return false; &#125; //此处坐标反了，和递归函数的赋值不对应 void search(int pos_x, int pos_y, int n, int m, int k, string word, bool&amp; flag, vector&lt;int&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;//此处坐标反了，和递归函数的赋值不对应 if (k == word.size()) &#123;flag = true; return;&#125; char c = word[k]; //找了很久才发现的，board[pos_x][pos_y]，坐标反了，应该是board[pos_y][pos_x] if (pos_x &lt; m &amp;&amp; pos_y &lt; n &amp;&amp; pos_x &gt;= 0 &amp;&amp; pos_y &gt;= 0 &amp;&amp; board[pos_x][pos_y] == c) &#123; //up if (used[(pos_y - 1) * m + pos_x] == 0) &#123; used[(pos_y - 1) * m + pos_x] = 1; search(pos_y - 1, pos_x, n, m, k + 1, word, flag, used, board); used[(pos_y - 1) * m + pos_x] = 0; &#125; //down if (used[(pos_y + 1) * m + pos_x] == 0) &#123; used[(pos_y + 1) * m + pos_x] = 1; search(pos_y + 1, pos_x, n, m, k + 1, word, flag, used, board); used[(pos_y + 1) * m + pos_x] = 0; &#125; //left if (used[pos_y * m + (pos_x - 1)] == 0) &#123; used[pos_y * m + (pos_x - 1)] = 1; search(pos_y, pos_x - 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + (pos_x - 1)] = 0; &#125; //right if (used[pos_y * m + (pos_x + 1)] == 0) &#123; used[pos_y * m + (pos_x + 1)] = 1; search(pos_y, pos_x + 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + (pos_x + 1)] = 0; &#125; &#125; &#125;&#125;; 修改之后，能运行但超时的版本，后面的版本没有超时的原因是，通过与(||)操作的短路原理来实现剪枝，一旦发现一个true则不再执行后续的内容。1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); //vector&lt;vector&lt;int&gt;&gt; first; vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; bool flag = false; search(i, j, n, m, 0, word, flag, used, board); &#125; &#125; return false; &#125; void search(int pos_y, int pos_x, int n, int m, int k, string word, bool&amp; flag, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) &#123;flag = true; return;&#125; if (pos_x &lt; m &amp;&amp; pos_y &lt; n &amp;&amp; pos_x &gt;= 0 &amp;&amp; pos_y &gt;= 0 &amp;&amp; board[pos_y][pos_x] == word[k]) &#123; if (used[pos_y * m + pos_x] == true) return; used[pos_y * m + pos_x] = true; //up search(pos_y - 1, pos_x, n, m, k + 1, word, flag, used, board); //down search(pos_y + 1, pos_x, n, m, k + 1, word, flag, used, board); //left search(pos_y, pos_x - 1, n, m, k + 1, word, flag, used, board); //right search(pos_y, pos_x + 1, n, m, k + 1, word, flag, used, board); used[pos_y * m + pos_x] = false; &#125; else return; &#125;&#125;; 加入与操作，不能通过版123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (search(i, j, n, m, 0, word, used, board)) return true; &#125; &#125; return false; &#125; bool search(int pos_y, int pos_x, int n, int m, int k, string word, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) return true; //问题就在board[pos_x][pos_y]坐标反了，半天没查出来 if (pos_x &gt;= m || pos_y &gt;= n || pos_x &lt; 0 || pos_y &lt; 0 || used[pos_y * m + pos_x] == true ||board[pos_x][pos_y] != word[k]) return false; used[pos_y * m + pos_x] = true; bool res = search(pos_y - 1, pos_x, n, m, k + 1, word, used, board) //up || search(pos_y + 1, pos_x, n, m, k + 1, word, used, board) //down || search(pos_y, pos_x - 1, n, m, k + 1, word, used, board) //left || search(pos_y, pos_x + 1, n, m, k + 1, word, used, board); //right used[pos_y * m + pos_x] = false; return res; &#125;&#125;; 调了半天后的AC版12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.empty()) return true; if (board.empty() || board[0].empty()) return false; int n = board.size(); int m = board[0].size(); vector&lt;bool&gt; used(n * m, false); for (int i = 0; i &lt; n; i ++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (search(i, j, 0, n, m, word, used, board)) return true; &#125; &#125; return false; &#125; bool search(int pos_y, int pos_x, int k, int n, int m,string word, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (k == word.size()) return true; if (pos_x &gt;= m || pos_y &gt;= n || pos_x &lt; 0 || pos_y &lt; 0 || used[pos_y * m + pos_x] == true || board[pos_y][ pos_x] != word[k]) return false; used[pos_y * m + pos_x] = true; bool res = search(pos_y - 1, pos_x, k + 1, n, m, word, used, board) //up || search(pos_y + 1, pos_x, k + 1, n, m, word, used, board) //down || search(pos_y, pos_x - 1, k + 1, n, m, word, used, board) //left || search(pos_y, pos_x + 1, k + 1, n, m, word, used, board); //right used[pos_y * m + pos_x] = false; return res; &#125;&#125;; 211. Add and Search Word - Data structure designDescription Design a data structure that supports the following two operations:12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. For example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. Hint:You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.解题思路：不愧是boss关，不会做。建立字典树，然后通过字典树查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546class WordDictionary &#123;public: /** Initialize your data structure here. */ struct TrieNode &#123; public: TrieNode *child[26]; bool isWord; TrieNode() : isWord(false) &#123; for (auto &amp;a: child) &#123; a = NULL;&#125; &#125; &#125;; WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ void addWord(string word) &#123; TrieNode *p = root; for (auto &amp;a: word) &#123; int i = a - 'a'; if (!p -&gt; child[i]) p -&gt; child[i] = new TrieNode(); p = p -&gt; child[i]; &#125; p -&gt; isWord = true; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ bool search(string word) &#123; return searchWord(word, root, 0); &#125; bool searchWord(string&amp; word, TrieNode *p, int i) &#123; if (i == word.size()) return p -&gt; isWord; if (word[i] == '.') &#123; for (auto &amp;a: p -&gt; child) &#123; if (a &amp;&amp; searchWord(word, a, i + 1)) return true; &#125; return false; &#125; else &#123; return p -&gt; child[word[i] - 'a'] &amp;&amp; searchWord(word, p -&gt; child[word[i] - 'a'], i + 1); &#125; &#125; private: TrieNode *root;&#125;; Hard52. N-Queens IIDescription:Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 解题思路：深度优先方法，剔除掉对角线(其实是左上和右上)以及上方可能出现的棋子的情况进行递归和返回。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int totalNQueens(int n) &#123; vector&lt;bool&gt; used(n * n, false); return func(0, n, used); &#125; int func(int i, int n, vector&lt;bool&gt;&amp; used) &#123; int cnt = 0; if (i == n) return 1; for (int j = 0; j &lt; n; j ++) &#123; bool f = true; for (int ii = 0; ii &lt; i; ii ++) &#123; if (used[ii *n + j]) &#123; f = false; break; &#125; &#125; if (f == false) continue; //加上之后，略快一点儿 int min = i &lt; j ? i : j; for (int a = 1; a &lt;= min; a++) &#123; if (used[(i - a) * n + j - a]) &#123; f = false; break; &#125; &#125; if (f == false) continue; min = i &lt; (n - j - 1) ? i : (n - j - 1); for (int a = 1; a &lt;= min; a++) &#123; if (used[(i -a) * n + j + a]) &#123; f = false; break; &#125; &#125; if (f) &#123; used[i * n + j] = true; cnt += func(i + 1, n , used); used[i * n + j] = false; &#125; &#125; return cnt; &#125;&#125;; 51. N-QueensDescription:The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle:1234567891011[ [".Q..", // Solution 1 "...Q", "Q...", "..Q."], ["..Q.", // Solution 2 "Q...", "...Q", ".Q.."]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; table; for (int i = 0; i &lt; n; i++) &#123; string tmp = ""; for (int j = 0; j &lt; n; j ++) &#123; tmp += ((i ==j) ? 'Q' : '.'); &#125; table.push_back(tmp); &#125; vector&lt;string&gt; tmp; vector&lt;bool&gt; used(n * n, false); func(0, n, used, table, tmp, res); return res; &#125; void func(int i, int n, vector&lt;bool&gt;&amp; used, vector&lt;string&gt;&amp; table, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; int cnt = 0; if (i == n) res.push_back(tmp); for (int j = 0; j &lt; n; j ++) &#123; bool f = true; for (int ii = 0; ii &lt; i; ii ++) &#123; if (used[ii *n + j]) &#123; f = false; break; &#125; &#125; if (f == false) continue; int min = i &lt; j ? i : j; for (int a = 1; a &lt;= min; a++) &#123; if (used[(i - a) * n + j - a]) &#123; f = false; break; &#125; &#125; if (f == false) continue; min = i &lt; (n - j - 1) ? i : (n - j - 1); for (int a = 1; a &lt;= min; a++) &#123; if (used[(i -a) * n + j + a]) &#123; f = false; break; &#125; &#125; if (f) &#123; used[i * n + j] = true; tmp.push_back(table[j]); func(i + 1, n , used, table, tmp, res); tmp.pop_back(); used[i * n + j] = false; &#125; &#125; &#125; &#125;; OtherWorks Application笔试题 Coin GameDescription：There is a rectangular chessboard containing N*M cells, each of which either has one coin or nothing. You can move all the coins together in one direction (such as up, down, left, and right), but each time you can move these coins by only one cell. If any coins fall out of the chessboard, they must be thrown away. If it is required to keep K coins on the board, what is the minimum moves you have to take? Output -1 if you can not meet this requirement. 输入描述:The first line of the input are two positive integers n, representing the size of the board. For the next n line(s), each line has m numbers of characters, with ‘o’ indicating a coin, ‘.’ indicates an empty grid. The last line is a positive integer k, indicating the number of coins to be retained. 30% small input: 1 \le n,m \le 5, 0 \le k \le 2540% medium input: 1 \le n,m \le 10, 0 \le k \le 10030% large input: 1 \le n,m \le 100, 0 \le k \le 10000 输出描述:12Outputan integer that represents the number of moves, no solution output -1. 示例1输入123453 4.o..oooo..o.3 输出12 50% case通过率，复杂度过大，回溯如何剪枝？？？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int countFunc(int start_row, int end_row, int start_col, int end_col, vector&lt;vector&lt;char&gt;&gt; input) &#123; int cnt = 0; for (int i = start_row; i &lt; end_row; i++) &#123; for (int j = start_col; j &lt; end_col; j++) &#123; if (input[i][j] == 'o') cnt ++; &#125; &#125; return cnt;&#125;void func(int k, vector&lt;vector&lt;char&gt;&gt;&amp; input, int start_row, int end_row, int start_col, int end_col, int count, vector&lt;int&gt;&amp; res) &#123; int tmp_cnt = countFunc(start_row, end_row, start_col, end_col, input); if (tmp_cnt == k) &#123; res.push_back(count); return; &#125; else if (tmp_cnt &lt; k) return; // up if (start_row &lt; end_row) &#123; start_row += 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; start_row -= 1; &#125; // down if (start_row &lt; end_row) &#123; end_row -= 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; end_row += 1; &#125; // left if (start_col &lt; end_col) &#123; start_col += 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; start_col -= 1; &#125; // right if (start_col &lt; end_col) &#123; end_col -= 1; count += 1; func(k, input, start_row, end_row, start_col, end_col, count, res); count -= 1; end_col += 1; &#125; &#125;int main() &#123; int n, m, k; char tmp; cin &gt;&gt; n; cin &gt;&gt; m; vector&lt;char&gt; temp; vector&lt;vector&lt;char&gt;&gt; input; int i = 1; while (cin &gt;&gt; tmp) &#123; temp.push_back(tmp); if (i % m == 0) &#123; input.push_back(temp); temp = &#123;&#125;; &#125; i++; if (i == m * n + 1) &#123; cin &gt;&gt; k; &#125; &#125; vector&lt;int&gt; res; int start_row = 0; int end_row = input.size(); int start_col = 0; int end_col = input.size(); func(k, input, start_row, end_row, start_col, end_col, 0, res); if (res.empty()) cout &lt;&lt; -1 &lt;&lt; endl; else &#123; sort(res.begin(), res.end()); cout &lt;&lt; res[0] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017秋招——京东]]></title>
      <url>%2F2017%2F09%2F16%2F2017%E7%A7%8B%E6%8B%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%9A%E4%BA%AC%E4%B8%9C%2F</url>
      <content type="text"><![CDATA[大量数据结构的问题 查找方式有哪些，都有哪些区别； 数组和链表的区别，分别是怎么实现的； 哈希表是如何实现的； 如何实现平衡树； 介绍一下红黑树；博客1，博客2 如何实现树的遍历； 汉诺塔问题 深度学习方面 过拟合、欠拟合； 过拟合有哪些解决方法； 欠拟合有哪些解决方法； GoogleNet； 怎么样去检测图像中的汽车； 深度学习有哪些超参数 哈希 构造合适的散列函数 除余法除数选用较大的素数，降低冲突发生的可能 MAD法 非递归版本先序遍历12345678910111213141516void PreOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); cout &lt;&lt; p -&gt; val &lt;&lt; endl; p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); p = p -&gt; right; &#125; &#125;&#125; 中序遍历12345678910111213141516void InOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); cout &lt;&lt; p -&gt; val &lt;&lt; endl; p = p -&gt; right; &#125; &#125; &#125; 后序遍历 123456789101112131415161718192021void PostOrder(TreeNode* root) &#123;void InOrder(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while (p != NULL || !s.empty()) &#123; if (P != NULL) &#123; s.push(p); p = p -&gt; left; &#125; else &#123; p = s.top(); s.pop(); if (! p -&gt; right) &#123; cout &lt;&lt; p -&gt; val &lt;&lt; endl; &#125; p = p -&gt; right; &#125; &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[降维之PCA主成分分析原理]]></title>
      <url>%2F2017%2F09%2F15%2F%E9%99%8D%E7%BB%B4%E4%B9%8BPCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[背景在许多领域的研究与应用中，往往需要对反映事物的多个变量进行大量的观测，收集大量数据以便进行分析寻找规律。多变量大样本无疑会为研究和应用提供了丰富的信息，但也在一定程度上增加了数据采集的工作量，更重要的是在多数情况下，许多变量之间可能存在相关性，从而增加了问题分析的复杂性，同时对分析带来不便。如果分别对每个指标进行分析，分析往往是孤立的，而不是综合的。盲目减少指标会损失很多信息，容易产生错误的结论。 因此需要找到一个合理的方法，在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量间存在一定的相关关系，因此有可能用较少的综合指标分别综合存在于各变量中的各类信息。主成分分析与因子分析就属于这类降维的方法。 目的PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。能够对高维数据降维的算法包括： LASSO 主成分分析法 聚类分析 小波分析法 线性判别法 拉普拉斯特征映射 作用降维有什么作用呢？ 数据在低维下更容易处理、更容易使用； 相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示； 去除数据噪声 降低算法开销 常见的降维算法有主成分分析（principal component analysis,PCA）、因子分析（Factor Analysis）和独立成分分析（Independent Component Analysis，ICA）。 优化目标将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差） 注意：PCA的变换矩阵是协方差矩阵，K-L变换的变换矩阵可以有很多种（二阶矩阵、协方差矩阵、总类内离散度矩阵等等）。当K-L变换矩阵为协方差矩阵时，等同于PCA。 原理最大化样本点在基上的投影，使得数据点尽量的分离。令第一主成分的方向是$u_1$，我们的目标就是将样本点在该方向上的投影最大化，即： \max {\frac{1}{n} \sum_{i=1}^n < u_1,x_i >^2} \frac{1}{n}\sum_{i=1}^n < u_1, x_i > \rightarrow \frac{1}{n}\sum_{i=1}^n(x_1^Tu_1)^2=\frac{1}{n}\sum_{i=1}^n(x_1^Tu_1)^T(x_1^Tu_1) =\frac{1}{n} \sum_{i=1}^n(u_1^T x_1 x_1^T u_1)= \frac{1}{n}u_1^T \left( \sum_{i=1}^n x_1 x_1^T \right) u_1 = \frac{1}{n} u_1^T \left(XX^T \right) u_1其中的$X=[x_1,x_2,…,x_n]^T,x_i\in R^{m}$。那么优化函数就变成了： \max u_1^T\left(XX^T\right)u_1以上式子是个二次型，可以证明XX^T是半正定矩阵，所以上式必然有最大值。 \max u_1^T\left(XX^T\right)u_1=\max ||X^Tu_1||_2^2优化函数 max||Wx||_2 s.t. W^TW=I解释：==最大化方差同时最小化协方差==（PCA本质上是将方差最大的方向作为主要特征，并且在各个正交方向上将数据“离相关”）。最大化方差意味着，使得每个样本点在每个维度上与均值有很大差异，就是说非常有个性，有个性才能分辨出来；同时协方差越小的话表明样本之间的互相影响就非常小，如果协方差是0的话，表示两个字段完全独立。 寻找协方差矩阵的特征向量和特征值就等价于拟合一条能保留最大方差的直线或主成分。因为特征向量追踪到了主成分的方向，而最大方差和协方差的轴线表明了数据最容易改变的方向。根据上述推导，我们发现达到优化目标就等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将特征值按大小从上到下排列。协方差矩阵作为实对称矩阵，其主要性质之一就是可以正交对角化，因此就一定可以分解为特征向量和特征值。 步骤总结一下PCA的算法步骤： 设有$m$条$n$维(字段数)数据。 将原始数据按列组成$n$行$m$列矩阵X. (行数代表字段数目，一个字段就是取每个样本的该维度的数值；列数代表样本数目) 将$X$的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值 求出协方差矩阵$C=\frac{1}{m}XX^T$ 求出协方差矩阵的特征值及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P $Y=PX$即为降维到k维后的数据 去均值化的目的下面两幅图是数据做中心化（centering）前后的对比，可以看到其实就是一个平移的过程，平移后所有数据的中心是(0,0). 在做PCA的时候，我们需要找出矩阵的特征向量，也就是主成分（PC）。比如说找到的第一个特征向量是a = [1, 2]，a在坐标平面上就是从原点出发到点（1，2）的一个向量。如果没有对数据做中心化，那算出来的第一主成分的方向可能就不是一个可以“描述”（或者说“概括”）数据的方向了。还是看图比较清楚。 黑色线就是第一主成分的方向。只有中心化数据之后，计算得到的方向才能比较好的“概括”原来的数据。 限制PCA虽可以很好的解除线性相关，但是对于高阶相关性就没有办法了，对于存在高阶相关性的数据，可以考虑Kernel PCA，通过Kernel函数将非线性相关转为线性相关 参考 PCA的数学原理 K-L变换和PCA的区别 从PCA和SVD的关系拾遗 数据什么时候需要做中心化和标准化处理 主成分分析（PCA）原理详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F09%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment More Tips:Latex math symbol http://blog.csdn.net/qq_33699981/article/details/72716951]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>%2F2017%2F09%2F13%2F%E5%BF%AB%E6%8E%92%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[博客上的代码1 博客上的代码2 1234567891011121314151617void quickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; int i = left; int j = right; int temp = array[left]; while (i != j) &#123; while (i &lt;j &amp;&amp; temp &lt;= array[j]) j --; if (i &lt; j) array[i] = array[j]; while (i &lt; j &amp;&amp; temp &gt; array[i]) i ++; if (i &lt; j) array[j] = array[i]; &#125; array[i] = temp; quickSort(array, left, i - 1); quickSort(array, i + 1, right);&#125; 分治思想 1234567891011121314151617181920212223int partition(vector&lt;int&gt;&amp; array, int left, int right) &#123; int i = left; int j = right; int temp = array[left]; while (i != j) &#123; while (i &lt;j &amp;&amp; temp &lt;= array[j]) j --; if (i &lt; j) array[i] = array[j]; while (i &lt; j &amp;&amp; temp &gt; array[i]) i ++; if (i &lt; j) array[j] = array[i]; &#125; array[i] = temp; return i;&#125;void quickSort(vector&lt;int&gt;&amp; array, int left, int right) &#123; if (left &lt; right) &#123; int dp = partition(array, left, right); quickSort(array, left, dp - 1); quickSort(array, dp + 1, right); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[优化算法]]></title>
      <url>%2F2017%2F08%2F13%2F%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[优化算法对目标函数求梯度 $\nabla_{\theta} J(\theta)$ 批量梯度下降利用所有训练数据，计算目标函数梯度，$\eta$是学习率(learning rate) \theta = \theta - \eta \cdot \nabla_{\theta} J(\theta)缺点：一次参数更新需要计算整体数据的梯度，内存消耗大，不支持模型在线更新 随机梯度下降训练中，利用一个样本$x^{(i)}$ 和标签 $y^{(i)}$进行一次参数更新 \theta = \theta - \eta \cdot \nabla J(\theta;x^{(i)};y^{(i)})优点： 速度快，支持在线学习 缺点： 高方差，目标函数值剧烈波动 随机波动，容易陷入局部极小值 mini-batch 随机下降结合前两种，在训练中，利用一个 batch 样本$x^{(i)}$ 和标签 $y^{(i)}$进行一次参数更新 \theta = \theta - \eta \cdot \nabla J(\theta;x^{(i:i+n)};y^{(i:i+n)})优点： 减小参数更新的方程，收敛更平稳 可以根据内存来控制输入 Momentum帮助SGD在相关方向上加速并抑制震荡，当前向量 v_{t} 的更新考虑了上一个时刻向量 v_{t-1} 的作用 \left\{ \begin{aligned} v_t & = &\underbrace{\gamma v_{t-1}}_{momenturm \,term} &+& \eta \cdot \nabla_{\theta} J(\theta)\\ \theta & = &\theta &-& v_t \\ \end{aligned} \right.Nesterov accelerated gradient(NAG)给momentum term引入先验 \left\{ \begin{aligned} v_t & = \gamma v_{t-1} + \eta \cdot \nabla_{\theta} J(\theta - \gamma v_{t-1})\\ \theta & = \theta - v_t \\ \end{aligned} \right.AdaGrad之前的方法对所有参数$\theta$都用了相同的学习率$\eta$，AdaGrad在时刻$t$对每个参数$\theta_i$采用了不同的学习速率$\eta$$\theta_i$在$t$时刻的梯度： g_{t,i} = \nabla_\theta J(\theta_i)SGD对在$t$时刻的参数$\theta_i$更新， \theta_{t+1, i} = \theta_{t,i} - \eta \cdot g_{t,i}AdaGrad在$t$时刻的参数$\theta_i$更新， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{G_{t,i} + \epsilon}} \cdot g_{t,i}其中，$G_{t} \in \mathbb{R}^{d \times d}$是一个对角矩阵，对角元素$i$是每个参数$\theta_i$到t时刻为止，所有时刻梯度的平方之和，$\epsilon$为避免分母为0。进一步，写成element-wise matrix-vector multiplication形式， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{G_{t} + \epsilon}} \odot g_{t}优点 不用人工调整学习率，默认0.01 缺点 在分母中累积梯度的平方，在训练过程中导致学习率一直在减小 需要手动设置一个全局初始学习率 更新$\theta_t$时，左右两边的单位不一致 Adadelta为缓解AdaGrad学习率单调递减问题做出的扩展。不对过去所以时刻梯度平方累积，将累积时刻限制在窗口大小为$w$的区间递归使得定义为过去所有时刻梯度平方的decaying average(?)。时刻$t$的running average $E[g^2]_t$仅仅依赖于之前average和当前的梯度$\gamma$是一个衰减系数，随着时间指数衰减，因此与当前时刻比较近的$g_t$对梯度计算更起作用 E[g^2]_t = \gamma E[g^2]_{t-1} + (1-\gamma)g^2_t将对角矩阵$G_t$替换为过去$t$时刻梯度平方的dacaying average $E[g^2]_t$ \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{E[g^2]_t + \epsilon}} \odot g_{t}RMSprop和Adadelta原理相似？？？ AdamAdaptvie Moment Estimation (Adam) 自适应学习速率计算方法。保存过去梯度平方和+momentum。 m_t=\beta_1 m_{t-1} + (1 - \beta_1) g_t\\ v_t = \beta_2 v_{t - 1} + (1 - \beta_2) g_t^2其中，$m_t$和$v_t$分别是梯度的一阶矩（均值）和二阶矩（偏方差）的估计为消除估计值的偏差，计算bias-corrected \widehat{m}_t = \frac{m_t}{1-\beta^t_1}\\ \widehat{v}_t = \frac{v_t}{1 - \beta^t_2}更新规则， \theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{\widehat{v}_t + \epsilon}} \widehat{m}_t默认设置，$\beta_1 = 0.9,\beta_2=0.999,\epsilon=10^{-8}$ 【各优化算法对比-投影面】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习修炼手册]]></title>
      <url>%2F2017%2F05%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BF%AE%E7%82%BC%E6%89%8B%E5%86%8C%2F</url>
      <content type="text"><![CDATA[对机器学习的学习我开始于二年级的《数据挖掘》课，当时袁老师对数据挖掘中的常用的算法做了一些介绍，但是这仅仅是个入门教学，我并没有深入了解的其中的原理。到现在我才深刻的意识到ML的重要性，我就抽空看了一些这方面的资料，整理了这一份文档。 机器学习算法包括，监督学习(回归、分类)以及非监督学习(聚类)。 梯度下降\bbox[5px,border:2px solid red] { \theta_j:=\theta_j-\alpha\frac{\partial}{\partial \theta}J(\theta) }其中$\alpha$为学习率一般为很小的数字(0.001-0.1)，$\theta$为我们需要求解的参数，$J(\theta)$为能量函数或者为损失函数，通过上述公式可知，梯度下降是沿着损失函数梯度的反方向寻找迭代寻找最优值的过程。梯度下降容易陷入局部最极小点，所以我们要采取一定的措施来阻止这种现象的发生。 过拟合（Overfitting）如果训练样本的特征过多，我们学习的假设可能在训练集上表现地很好，但是在验证集上表现地就不尽人意 避免过拟合 减少特征的大小 正则化 在保证所有特征都保留的情况下，限制$\theta$的大小，即Small values for parameters $ \theta_0,\theta_1,\theta_2…\theta_n$ 当特征量很多时，该方式仍然表现的很好 交叉验证(Cross Validation) 正则化线性回归对于线性回归而言，其损失函数形式如下： J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)^2引入正则化之后的损失函数的形式为： J(\theta)=\frac{1}{2m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2+\lambda\sum_{j=1}^{n}\theta_{j}^2\right)GD迭代求解参数Repeat{ \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)x_0^{(i)} \theta_j:=\theta_j-\alpha\frac{1}{m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda\theta_j\right)}梯度下降法的学习率$\alpha$需要提前指定，并且还要制定收敛标准。 Normal Equation \theta=\left(x^Tx+\lambda\begin{bmatrix} {0}&{0}&{\cdots}&{0}\\ {0}&{1}&{\cdots}&{0}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{1}\\ \end{bmatrix}_{(n+1)(n+1)}\right)^{-1}x^Ty上式是对线性回归正则化后的矩阵解。可以证明的是当$\lambda&gt;0$时，求逆符号内部的式子总是可逆的。 逻辑回归在没有加入正则化之前，逻辑回归的损失函数的形式是这样的： J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}\left(y^{(i)}\log\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})\log\left(1-h_{\theta}(x^{(i)})\right)\right)加入正则项之后的形式为： J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}\left(y^{(i)}\log\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})\log\left(1-h_{\theta}(x^{(i)})\right)\right)+\frac{\lambda}{2m}\sum_{j=1}^{n}\theta_j^2GD迭代求解参数Repeat{ \theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}\left(h_{\theta}(x^{(i)})-y^{(i)}\right)x_0^{(i)}\theta_j:=\theta_j-\alpha\frac{1}{m}\left(\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}+\lambda\theta_j\right)} SVM支持向量机支持向量机又被称作最大间距（Large Margin）分类器，损失函数的形式是： J(\theta)=C\sum_{i=1}^{m}\left(y^{(i)}cost_1\left(h_{\theta}(x^{(i)})\right)+(1-y^{(i)})cost_0\left(h_{\theta}(x^{(i)})\right)\right)+\frac{1}{2}\sum_{j=1}^{n}\theta_j^2其中：$h_{\theta}(x^{(i)})=\theta^Tx^{i}$，$cost_1$以及$cost_0$的形式如下图所示： \begin{cases} \text{we want } \theta^Tx\ge1, & \text{if $y$ =1} \\[2ex] \text{we want } \theta^Tx\le-1, & \text{if $y$ =0} \end{cases}]]></content>
    </entry>

    
  
  
</search>
